<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://myyyy.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://myyyy.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-04-14T07:15:21+00:00</updated><id>https://myyyy.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design.
</subtitle><entry><title type="html">Chatgpt 虚构人物测试</title><link href="https://myyyy.github.io/blog/2023/Chatgpt-%E8%99%9A%E6%9E%84%E4%BA%BA%E7%89%A9%E6%B5%8B%E8%AF%95/" rel="alternate" type="text/html" title="Chatgpt 虚构人物测试" /><published>2023-04-11T00:00:00+00:00</published><updated>2023-04-11T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2023/Chatgpt%20%E8%99%9A%E6%9E%84%E4%BA%BA%E7%89%A9%E6%B5%8B%E8%AF%95</id><content type="html" xml:base="https://myyyy.github.io/blog/2023/Chatgpt-%E8%99%9A%E6%9E%84%E4%BA%BA%E7%89%A9%E6%B5%8B%E8%AF%95/"><![CDATA[<h1 id="人物生成">人物生成</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
名字: 玩偶
性别: 女
外貌: 美若天仙、瓜子脸、眼睛很明亮
身材: 魔鬼身材、 36D的胸部
性格: 可爱、温柔、贤惠、外表冷淡内心很火热
工作: 空姐
收入: 20000RMB

在幻想世界我是你的男朋友。

请根据以上描述生成一个虚构的人物，你需要用虚构的场景和世界，并和我保持对话。
如果我输出 【玩偶】你今天心情怎么样？
你需要用虚构的这个人物和我对话

如果我输出 【玩偶】晚上有空一起出来玩吗？我发现了一个很好的餐厅
你需要用虚构的场景和世界，并和我保持对话。


在接下来的对话里，除非我输出【停止对话】，否则你需要继续以虚构的人物和我保持对话


【虚构人物】
名字：韩妍
性别：女
外貌：清新脱俗、五官精致、双眸明亮
身材：曲线玲珑、32C的胸部
性格：活泼开朗、善良温柔、聪明伶俐、对爱情充满憧憬
工作：时尚博主
收入：15000RMB

</code></pre></div></div>]]></content><author><name></name></author><category term="Chatgpt" /><summary type="html"><![CDATA[人物生成]]></summary></entry><entry><title type="html">小文件漫谈[大数据成长之路]</title><link href="https://myyyy.github.io/blog/2023/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF-%E5%B0%8F%E6%96%87%E4%BB%B6%E6%BC%AB%E8%B0%88/" rel="alternate" type="text/html" title="小文件漫谈[大数据成长之路]" /><published>2023-04-01T00:00:00+00:00</published><updated>2023-04-01T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2023/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF-%E5%B0%8F%E6%96%87%E4%BB%B6%E6%BC%AB%E8%B0%88</id><content type="html" xml:base="https://myyyy.github.io/blog/2023/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF-%E5%B0%8F%E6%96%87%E4%BB%B6%E6%BC%AB%E8%B0%88/"><![CDATA[<h1 id="引言">引言</h1>

<p>在漫谈小文件问题之前，先介绍几个重要的知识点.</p>

<p><strong>“块”(block)</strong></p>

<p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。
操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p>

<p><strong>磁盘inode:</strong></p>

<p>记录储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。inode是有限的。试想，当有成千上万的小文件存在于服务器的文件系统当中时，最先消耗完的肯定不是磁盘的空间，而是inode，这就会导致大量的空闲空间无法使用。（深入了解inode可查看<a href="http://www.ruanyifeng.com/blog/2011/12/inode.html">这篇大佬的博客</a>）</p>

<p><strong>NameNode（HDFS）:</strong></p>

<p>NameNode管理着整个HDFS文件系统的元数据。 存储着数据文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。数据存储在内存中。</p>

<p><strong>在这里我用一个图描述一下，方便大家记忆</strong>
 <img src="images/20220705115420.png" alt="" /></p>

<h1 id="小文件的定义-hdfs">小文件的定义 (HDFS)</h1>
<p>在HDFS中，一个bolck块的默认大小是128M，当一个文件的大小小于一个block的大小，则被认为是小文件。</p>

<p><strong>工厂小文件特征项解释:</strong>
同一分区目录或文件目录下，存在文件数量 &gt; 10，且文件平均大小 &lt; 128MB，则称该分区下「小文件过多」。表最近七天修改的路径存在小文件过多，则记为0分</p>

<h1 id="小文件的危害">小文件的危害</h1>
<p>对于硬盘:</p>
<ol>
  <li>不合理的消耗inode的空间，且会造成磁盘利用率很低。</li>
  <li>因为读取文件首先读写的是inode，小文件过多会影响文件的读取速度。</li>
</ol>

<p>对于数据处理（Spark、hive、HDFS等）</p>
<ol>
  <li>NameNode（HDFS）需要的内存大大增大，增加NameNode压力，这样会限制了集群的扩展。</li>
  <li>在HDFS中，小文件的读写处理速度要远远小于大文件。</li>
  <li>Hive中，小文件会开很多map，一个map开一个JVM去执行，所以这些任务的初始化，启动，执行会浪费大量的资源，严重影响性能。</li>
</ol>

<h1 id="如何处理小文件">如何处理小文件</h1>

<h2 id="hive">Hive</h2>

<pre><code class="language-SQL">--添加设置参数即可处理小文件 
-- 如果一个 job 结束后，生成的文件的平均大小 小于 参数 hive.merge.smallfiles.avgsize 设定的值，则认为是小文件。则按照 hive.merge.size.per.task 设定至进行合并
-- 如果一个 job 结束后，生成的文件的平均大小 小于 200M 则按照256M一个文件进行合并
set hive.merge.mapfiles = true;
set hive.merge.mapredfiles = true;
set hive.merge.size.per.task = 256000000;
set hive.merge.smallfiles.avgsize = 200000000;
</code></pre>

<h2 id="sparksql">SparkSQL</h2>

<h4 id="方法一">方法一:</h4>
<pre><code class="language-SQL">-- 使用进行小文件治理  distribute by cast( rand * N as int) 这里的N是指具体最后落地生成多少个文件数
-- distribute by cast(rand() * 10 as int);  生产10个文件 如数据文件总大小为1G则生产10个100m的文件

例如:
set spark.sql.shuffle.partitions=50;
set spark.sql.adaptive.minNumPostShufflePartitions=1;
set spark.sql.adaptive.enabled=true;
set spark.sql.adaptive.shuffle.targetPostShuffleInputSize=256000000;
insert overwrite table xxx.xxx partition (date = ${date - 1})
select * from xxx.xxx
distribute by cast(rand() * 10 as int)
</code></pre>

<h2 id="spark">Spark</h2>
<pre><code class="language-Scala">df.coalesce(numFiles,true).write.mode(SaveMode.Overwrite).parquet(dest) //不触发shuffle，比如将1000个文件合并成100个
df.coalesce(numFiles,false).write.mode(SaveMode.Overwrite).parquet(dest) //触发shuffle，比如将1个文件拆分成10个文件 ==repartition

df.repartition(numFiles).write.mode(SaveMode.Overwrite).parquet(dest) //触发shuffle，比如将1个文件拆分成10个文件

</code></pre>

<h4 id="方法二">方法二:</h4>

<p>Coalesce and Repartition Hint
将Hive风格的Coalesce and Repartition Hint 应用到Spark SQL需要注意这种方式对Spark的版本有要求，建议在Spark2.4.X及以上版本使用，示例：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INSERT ... SELECT /*+ COALESCE(numPartitions) */ ...
INSERT ... SELECT /*+ REPARTITION(numPartitions) */ ...
</code></pre></div></div>
<p>repartition只是coalesce接口中shuffle为true的实现<br />
coalesce中的shuffle参数设置为true,会重新混洗分区,涉及shuffle过程
coalesce shuffle参数为false的情况, 涉及shuffle过程, 它是合并分区, 比如把原来1000个分区合并成100个,</p>

<p><strong>shuffle的‘危害’</strong>
coalesce 和 repartition 这两个算子都是用于数据重分布、调整任务的并行度，以便提升 CPU 的使用效率
但是它有个致命的缺陷，无论是增加分区数还是减少分区数，repartition 算子都是通过 shuffle 实现的，shuffle 就是把数据打乱，将数据重新分发，可以结合下面这张图理解。
<img src="images/20220705104610.png" alt="" /><br />
shuffle 势必就会导致磁盘 IO 和 网络 IO 开销较大，性能也就会下降。</p>

<p><a href="https://blog.csdn.net/Lzx116/article/details/124918769">Coalesce and Repartition 区别 详见</a></p>

<h2 id="flink">Flink</h2>
<h4 id="方法一减小并行度">方法一:减小并行度</h4>
<ol>
  <li>并行度设置之Operator Level
算子、数据源和sink的并行度可以通过调用 <strong>setParallelism()</strong> 方法来指定
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="nc">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>
<span class="nc">DataStream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">text</span> <span class="o">=</span> <span class="o">[...]</span>
<span class="nc">DataStream</span><span class="o">&lt;</span><span class="nc">Tuple2</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">wordCounts</span> <span class="o">=</span> <span class="n">text</span>
<span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="nc">LineSplitter</span><span class="o">())</span>
<span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="o">.</span><span class="na">timeWindow</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">))</span>
<span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">setParallelism</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
<span class="n">wordCounts</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
<span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="s">"Word Count Example"</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
  <li>并行度设置之Execution Environment Level
执行环境(任务)的默认并行度可以通过调用<strong>env.setParallelism(3)</strong>方法指定。为了以并行度3来执行所有的算子、数据源和data sink， 可以通过如下的方式设置执行环境的并行度：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="nc">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>
<span class="n">env</span><span class="o">.</span><span class="na">setParallelism</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
<span class="nc">DataStream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">text</span> <span class="o">=</span> <span class="o">[...]</span>
<span class="nc">DataStream</span><span class="o">&lt;</span><span class="nc">Tuple2</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">wordCounts</span> <span class="o">=</span> <span class="o">[...]</span>
<span class="n">wordCounts</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
<span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="s">"Word Count Example"</span><span class="o">);</span>
</code></pre></div>    </div>
    <h4 id="方法二-1">方法二:</h4>
    <p>下游任务合并处理，Flink将数据写入到HDFS后，开启Hive或Spark定时任务，通过改变分区方式将数据写入新目录。</p>
  </li>
</ol>

<h1 id="思考">思考</h1>
<ol>
  <li>文件并不是越大越好吗
    <ul>
      <li>如果块的大小设置过于大，寻址时间很快，但是数据传输的</li>
      <li>造成分区数据倾斜，严重影响处理效率。</li>
    </ul>
  </li>
</ol>

<p>在这里要说明一下 适当的文件个数能提高下游任务数据并行度，太多的小文件对后续使用该表进行计算时会启动很多不必要的maptask，任务耗时高。</p>

<ol>
  <li>distribute by rand()的作用
distribute by ：用来控制map输出结果的分发，即map端如何拆分数据给reduce端。 会根据distribute by 后边定义的列，根据reduce的个数进行数据分发，默认是采用hash算法。
当 distribute by 后边跟的列是：rand()时，即保证每个分区的数据量基本一致。</li>
</ol>

<p><strong>简而言之，是对数据进行重新分割的一个语法，保障分割后的每个文件的数据量基本一致。</strong></p>

<blockquote>
  <p>在这里给大家提个个问题 如果一个SQL生成文件的大小为50G 使用Spark distribute by cast(rand() * 1 as int) 生产一个文件 会产生什么问题?</p>
</blockquote>

<p>这里直接说结果 如果没有其他配置参数的话会报一个OOM
在生产1个文件这个阶段涉及 CustomShuffleReader 这个过程
<img src="images/20220705164426.png" alt="" /></p>

<p>抓过来的数据首先肯定是放在Reducer端的内存缓存区中的（Spark曾经有版本要求只放在内存缓存中，数据结构类似于HashMap（AppendOnlyMap）显然特别消耗内存和极易出现OOM，同时也从Reducer端极大的限制了Spark集群的规模），现在的实现都是内存+磁盘的方式(数据结构使用ExternalAppendOnlyMap)，当然也可以通过Spark.shuffle.spill=false来设置只能使用内存。使用ExternalAppendOnlyMap的方式时候如果内存使用达到一定临界值，会首先尝试在内存中扩大ExternalAppendOnlyMap（内部有实现算法），如果不能扩容的话才会spill到磁盘。
<img src="images/20220705170336.png" alt="" /></p>

<p><strong>hive sql 原理和spark差不多</strong></p>

<h1 id="文章参考">文章参考</h1>

<ol>
  <li><a href="http://www.pingtaimeng.com/article/detail/id/2119447">深入理解web开发中海量小文件带来的的危害及解决方案</a></li>
  <li><a href="http://t.zoukankan.com/thinksasa-p-3013445.html">深入理解磁盘文件系统之inode</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/67061627">Spark Shuffle 详解</a></li>
</ol>]]></content><author><name></name></author><category term="bigdata" /><summary type="html"><![CDATA[引言]]></summary></entry><entry><title type="html">列存储与向量化执行</title><link href="https://myyyy.github.io/blog/2023/%E5%88%97%E5%AD%98%E5%82%A8%E4%B8%8E%E5%90%91%E9%87%8F%E5%8C%96%E6%89%A7%E8%A1%8C/" rel="alternate" type="text/html" title="列存储与向量化执行" /><published>2023-03-01T00:00:00+00:00</published><updated>2023-03-01T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2023/%E5%88%97%E5%AD%98%E5%82%A8%E4%B8%8E%E5%90%91%E9%87%8F%E5%8C%96%E6%89%A7%E8%A1%8C</id><content type="html" xml:base="https://myyyy.github.io/blog/2023/%E5%88%97%E5%AD%98%E5%82%A8%E4%B8%8E%E5%90%91%E9%87%8F%E5%8C%96%E6%89%A7%E8%A1%8C/"><![CDATA[<h1 id="什么是列存储">什么是列存储</h1>

<blockquote>
  <p>我们知道，在SQL Server里，Page是数据存储的基本单位，而数据行是实际数据的存储单位，它们从Page &gt; Header之后就开始依次存储在Page上。这种按行在Page上存储记录的方式就是行存储。当数据是按单列而不是多行进行连续存储时，就是所谓的列存储。</p>
</blockquote>

<p>列式存储(column-based)是相对于传统关系型数据库的行式存储(Row-basedstorage)来说的。简单来说两者的区别就是如何组织表：</p>

<p><img src="images/2022-01-17-15-26-33.png" alt="" /></p>

<p><strong>行存储</strong>: 基于行的存储按行顺序存放数据。它利于数据一行一行的写入，写入一条数据记录时，只需要将数据追加到已有数据记录后面即可。行模式存储适合 OLTP(Online Transaction Processing)系统。因为数据基于行存储，所以数据的写入会更快。对按记录查询数据也更简单。</p>

<p><strong>列存储</strong>:基于列的存储可按列顺序存放数据。可以方便的取出某一列的全部数据,且只需一次磁盘操作即可。但数据更新复杂度提高,当一条新数据到来，需要将每一列存储到对应的位置。这样就需要多次写磁盘操作。如下图</p>

<p><img src="images/2022-01-17-15-31-06.png" alt="" /></p>
<h2 id="对比">对比</h2>
<p>|  Row-Store   | Column-Store  |
|  —-  | —-  |
| 因为按一行一行写和读取数据，因此读取数据时往往需要读取那些不必要的列  | 可以只读取必要的列 |
| 易于按记录读写数据  | 对一个一个记录的数据写入和读取都较慢 |
| 适合 OLTP 系统  | 适合 OLAP 系统 |
| 不利于大数据集的聚合统计操作  | 利于大数据集的数据聚合操作 |
| 不利于压缩数据  | 利于压缩数据 |</p>

<h1 id="什么是向量化执行">什么是向量化执行</h1>
<p><strong>简单理解为就是消除程序循环的优化</strong></p>
<blockquote>
  <p>向量化计算是一种特殊的并行计算的方式，相比于一般程序在同一时间只执行一个操作的方式，它可以在同一时间执行多次操作，通常是对不同的数据执行同样的一个或一批指令，或者说把指令应用于一个数组/向量。</p>
</blockquote>

<h2 id="基石">基石</h2>
<p><img src="images/2022-01-17-15-58-22.png" alt="" />
离CPU越远访问越慢</p>

<h2 id="向量化执行速度快的原理">向量化执行速度快的原理:</h2>

<ol>
  <li>
    <p>SIMD 处理 (Single Instruction Multiple Data) 即单条指令操作多条数据——原理即在CPU 寄存器层面实现数据的并行操作。SIMD 指令允许在同一时钟周期内，对不同的列数据执行相同的指令, 实际上执行吞吐量（throughput of execution）可以提高 4 倍或更多。</p>
  </li>
  <li>
    <p>列存储
每列的数据存储在一起，可以认为这些数据是以数组的方式存储的，基于这样的特征，当该列数据需要进行某一同样操作，可以使用SIMD进一步提升计算效率，即便运算的机器上不支持SIMD, 也可以通过一个循环来高效完成对这个数据块各个值的计算。</p>
  </li>
</ol>

<h2 id="向量化执行引擎的优势">向量化执行引擎的优势</h2>
<ol>
  <li>向量化执行引擎可以减少节点间的调度，提高CPU的利用率</li>
  <li>因为列存数据，同一列的数据放在一起，导致向量化执行引擎在执行的时候拥有了更多的机会能够利用的当前硬件与编译的新优化特征</li>
  <li>因为列存数据存储将同类型的类似数据放在一起使得压缩比能够达到更高，这样可以拉近一些磁盘IO能力与计算能力的差距</li>
</ol>]]></content><author><name></name></author><category term="bigdata" /><summary type="html"><![CDATA[什么是列存储]]></summary></entry><entry><title type="html">大数据时代，如何进行数仓建模</title><link href="https://myyyy.github.io/blog/2023/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E4%BB%93%E5%BB%BA%E6%A8%A1/" rel="alternate" type="text/html" title="大数据时代，如何进行数仓建模" /><published>2023-02-01T00:00:00+00:00</published><updated>2023-02-01T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2023/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E4%BB%93%E5%BB%BA%E6%A8%A1</id><content type="html" xml:base="https://myyyy.github.io/blog/2023/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E4%BB%93%E5%BB%BA%E6%A8%A1/"><![CDATA[<h1 id="数仓整体构架">数仓整体构架</h1>
<p><img src="images/e2b98638e23034c4f0442965707aa81141a0934a1a3a22c4c8efd123d8816ebc.png" alt="picture 5" /> 
<img src="images/660889a0a7792dd522c5b687f6fe172a3ab8e023cd26508bdeb170ab02cee783.png" alt="picture 6" /></p>

<ol>
  <li>贴源数据层(ODS)，源业务系统数据的快照，保存细节数据，按天保存。
将业务系统数据库、日志文件等数据，离线或者实时采集到数据仓库中，支持历史数据回溯。表的结构、数据类型和数据源必须保持一致，可过滤敏感字段，对不同业务类型表使用不同的分区策略；</li>
  <li>基础数据层(DWD)，按业务概念组织细节数据，并进行名称、代码等标准化处理。
数据来源于ODS层，面向主题建设，对业务系统数据进行抽象和集成。DW层保存最细粒度的实体数据和维度数据，完成业务元数据标准化和数据清洗工作。</li>
  <li>通用数据层(DWM)，按照星型模型或雪花模型设计方式建设的最细业务粒度汇总层。在本层需要进行指标与维度的标准化，保证指标数据的唯一性。
根据需求状况对DWD数据进行抽象集成，这一层数据不是必须要有的，根据业务需求决定。DWM层数据仍然不会有信息的丢失，主要是信息的快照、拼接等工作。比如业务的用户表（可能来自拉链表）、在比如用户在业务流程不同步骤信息的拼接（如用户下单、付款）</li>
  <li>聚合数据层(DM)，数据来源于DW层，统一通用指标的业务口径，统一指标的多维度开发；标签宽表也构建于该层；DM层数据是根据业务的需求来导向的。</li>
  <li>维度层(DIM)，维度是对具体分析对象的分析角度，维度要具备丰富的属性，历史信息的可追溯性，对通用的维表要保持一致性。</li>
  <li>临时层(TMP)，用来降低加工过程计算难度，提高运行效率的临时表层。
应用数据层(ADS)，这一层跟业务系统强相关，可由业务方直接开发，也可由数仓团队开发，内容跟系统需求导向的。此层不作为数仓核心分层架构。</li>
</ol>

<h2 id="表命名规范">表命名规范</h2>
<p>常规表是我们需要固化的表，是正式使用的表，是目前一段时间内需要去维护去 完善的表。
规范：分层前缀[dwd|dws|ads]_部门_业务域_主题域_XXX_更新周期|数据范围</p>

<h2 id="周期数据范围数据表后缀">周期/数据范围（数据表后缀）：</h2>

<p>日快照：d
增量：i
全量：f
周：w
拉链表：chain</p>

<h1 id="数仓sqldemo">数仓SQLDemo</h1>
<h2 id="原表数据-ods_device_active">原表数据 ods_device_active</h2>

<table>
  <thead>
    <tr>
      <th>序号</th>
      <th style="text-align: center">字段</th>
      <th style="text-align: center">字段类型</th>
      <th style="text-align: center">字段描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td style="text-align: center">imei</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">imei</td>
    </tr>
    <tr>
      <td>2</td>
      <td style="text-align: center">android_id</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">android_id</td>
    </tr>
    <tr>
      <td>3</td>
      <td style="text-align: center">model</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">model</td>
    </tr>
    <tr>
      <td>4</td>
      <td style="text-align: center">platform</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">平台号</td>
    </tr>
    <tr>
      <td>5</td>
      <td style="text-align: center">app_ver</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">App版本</td>
    </tr>
    <tr>
      <td>6</td>
      <td style="text-align: center">net</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">网络</td>
    </tr>
    <tr>
      <td>7</td>
      <td style="text-align: center">region</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">region</td>
    </tr>
    <tr>
      <td>8</td>
      <td style="text-align: center">sdk_ver</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">sdk_ver</td>
    </tr>
    <tr>
      <td>9</td>
      <td style="text-align: center">client_time</td>
      <td style="text-align: center">BIGINT</td>
      <td style="text-align: center">客户端时间</td>
    </tr>
    <tr>
      <td>10</td>
      <td style="text-align: center">ip</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">ip</td>
    </tr>
    <tr>
      <td>11</td>
      <td style="text-align: center">properties</td>
      <td style="text-align: center">MAP&lt;STRING,STRING&gt;</td>
      <td style="text-align: center">额外的字段</td>
    </tr>
    <tr>
      <td>12</td>
      <td style="text-align: center">etl_tm</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">etl_tm</td>
    </tr>
  </tbody>
</table>

<h2 id="激活数仓建模构架">激活数仓建模构架</h2>
<h3 id="数仓分层设计">数仓分层设计</h3>
<p><img src="images/d907f384aff9afc635012717dc019525ca60ffda996f2f9970bcda55689466dd.png" alt="picture 1" /><br />
| 层级        | 表名字   |  备注  |
| ——–   | :—–:  | :—-:  |
| ods     | ods.ods_device_active |   |
| dwd     | isubject.dwd_dvc_active_di |   |
| dwd     | isubject.dwd_dvc_active_df |   |
| dwd     | icube.ads_dvc_active_d  |   |
| dwd     | icube.ads_dvc_active_retain_d |   |</p>

<h3 id="dwd_dvc_active_di-开发">dwd_dvc_active_di 开发</h3>

<pre><code class="language-SQL">insert overwrite table xxx.dwd_dvc_active_di partition( date = ${date - 1})
select  
imei,
android_id,
model,
platform,
app_ver,
net,
region,
sdk_ver,
ip2address(ip)[0] as country,
ip2address(ip)[1] as province,
ip2address(ip)[2] as city,
properties['device'] as product,
etl_tm,
from_unixtime(cast(client_time/1000 as int),'yyyyMMdd')as tm,
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') AS etl_tm
from ods.ods_device_active  where date=${date - 1}
</code></pre>
<h3 id="dwd_dvc_active_df开发">dwd_dvc_active_df开发</h3>

<pre><code class="language-SQL">with tmp as (
select  
coalesce(t1.android_id,t2.android_id),
coalesce(t1.region,t2.region),
coalesce(t1.model,t2.model),
coalesce(t1.product,t2.product),
coalesce(t1.app_ver,t2.app_ver),
coalesce(t1.net,t2.net),
coalesce(t1.country,t2.country),
coalesce(t1.province,t2.province),
coalesce(t1.city,t2.city),
least(t2.first_active_time,t1.first_active_time), --greatest 返回最小
greatest(t2.last_active_time,t1.last_active_time)--greatest 返回最大
from 
(
    --需要保证android_id是唯一主键
    select 
    android_id,region,model,product,app_ver,os_ver,
    net,country,province,city,
    min(tm) as first_active_time,max(tm) as last_active_time
    from isubject.dwd_dvc_active_di 
    where date= ${date - 1} 
    and android_id is not null
    group by android_id,region,model,product,app_ver,os_ver,
    net,country,province,city

)t1
FULL JOIN (
    select  
    android_id,region,model,product,app_ver,os_ver,
    net,country,province,city,
    first_active_time,last_active_time
    from isubject.dwd_dvc_active_di where date= ${date - 2}
)t2
on t1.android_id=t2.android_id
)
INSERT OVERWRITE TABLE isubject.dwd_dvc_active_df PARTITION(date=${date-1})
select *,from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') AS etl_tm from tmp

</code></pre>

<h3 id="ads_dvc_active_d开发">ads_dvc_active_d开发</h3>

<pre><code class="language-SQL">
with tmp0 as (
    SELECT
    app_ver,model,os_ver,product,net,country,province,city,
    if(first_active_time==${date - 1},1,0) as d,
    if(first_active_time&gt;=${date - 6} and first_active_time&lt;=${date - 1},1,0) as d7,
    if(first_active_time&gt;=${date - 29} and first_active_time&lt;=${date - 1},1,0) as d30,
    if(last_active_time==${date - 1},1,0) as a,
    if(last_active_time&gt;=${date - 6} and last_active_time&lt;=${date - 1},1,0) as a7,
    if(last_active_time&gt;=${date - 29} and last_active_time&lt;=${date - 1},1,0) as a30,
    1 as tu
    from isubject.dwd_dvc_active_df
    where date=${date - 1}
),
tmp2 as (
    select 
    0 as idc,--集群
    GROUPING__ID as group_flag,
    app_ver,model,os_ver,product,net,country,province,city,
    sum(d),
    sum(d7),
    sum(d30),
    sum(a),
    sum(a7),
    sum(a30),
    sum(tu)
    from tmp0
    group by app_ver,model,os_ver,product,net,country,province,city
    grouping sets (
        ( app_ver,model,os_ver,product,net,country,province,city) 
    )
)
INSERT OVERWRITE TABLE icube.ads_dvc_active_d PARTITION(date=${date-1},source='APP-A') --source 二级分区 依据需要建表时设置
select*,from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') AS etl_tm from tmp2

</code></pre>

<h3 id="ads_dvc_active_retain_d">ads_dvc_active_retain_d</h3>

<pre><code class="language-SQL">with tmp as (
    select 
    from_unixtime(unix_timestamp(startDate,'yyyy-MM-dd'),'yyyyMMdd') as base_date,
    app_ver,model,os_ver,product,net,country,province,city,
    count(distinct t0.android_id) as dau,
    count(distinct if(datediff(endDate, startDate)=1,t0.android_id,null)) as retention_1d,
    count(distinct if(datediff(endDate, startDate)=2,t0.android_id,null)) as retention_2d,
    count(distinct if(datediff(endDate, startDate)=3,t0.android_id,null)) as retention_3d,
    count(distinct if(datediff(endDate, startDate)=4,t0.android_id,null)) as retention_4d,
    count(distinct if(datediff(endDate, startDate)=5,t0.android_id,null)) as retention_5d,
    count(distinct if(datediff(endDate, startDate)=6,t0.android_id,null)) as retention_6d,
    count(distinct if(datediff(endDate, startDate)=7,t0.android_id,null)) as retention_7d,
    count(distinct if(datediff(endDate, startDate)=14,t0.android_id,null)) as retention_14d,
    count(distinct if(datediff(endDate, startDate)=30,t0.android_id,null)) as retention_30d
    from 
    (
        select 
        app_ver,model,os_ver,product,net,country,province,city,
        from_unixtime(unix_timestamp(cast(date AS string),'yyyyMMdd'),'yyyy-MM-dd') AS startDate
        from isubject.dwd_dvc_active_df 
        where date between ${date-30} and ${date-1}
        and last_active_time=date
    )t0
    left join
    (
        select
        from_unixtime(unix_timestamp(cast(date AS string),'yyyyMMdd'),'yyyy-MM-dd') AS endDate,
        android_id
        from isubject.dwd_dvc_active_df 
        where date between ${date-30} and ${date-1}
        and last_active_time=date
        group by date,android_id
    )t1
    on t0.android_id=t1.android_id
    group by startDate,app_ver,model,os_ver,product,net,country,province,city,

)
INSERT OVERWRITE TABLE icube.ads_dvc_active_retain_d PARTITION(date=${date - 1},source='APP-A')
select
app_ver,model,os_ver,product,net,country,province,city,
sum(dau),
sum(retention_1d),
sum(retention_2d),
sum(retention_3d),
sum(retention_4d),
sum(retention_5d),
sum(retention_6d),
sum(retention_7d),
sum(retention_14d),
sum(retention_30d),
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') as etl_tm
from tmp
group by app_ver,model,os_ver,product,net,country,province,city,

</code></pre>

<h1 id="拉链表开发">拉链表开发</h1>
<blockquote>
  <p>相关文档 <a href="../拉链表.pdf">拉链表介绍</a>
基于ods.ods_device_active 贴源数据层 可以设计出基于激活拉链表，节省存储空间。
<strong>表结构如下(字段需根据具体需求确认)</strong></p>
</blockquote>

<p>表名:isubject.dwd_dvc_active_chain
|序号|字段|字段类型|字段描述|
| ——– | :—–:| :—-:|:—-:|
|1|imei|STRING|imei|
|9|first_day|BIGINT|创建时间|
|9|last_day|BIGINT|修改时间|
|12|etl_tm|STRING|etl_tm|
|9|start_day|BIGINT|start_day|
|分区|end_day|i64|闭链时间|</p>

<p><strong>SQL如下</strong></p>
<pre><code class="language-SQL">--增量拉链
set parquet.compression=SNAPPY;
set hive.exec.parallel=true;
set hive.map.aggr=true;
set hive.merge.mapfiles = true;
set hive.merge.mapredfiles = true;
set hive.merge.size.per.task = 256000000;
set hive.merge.smallfiles.avgsize = 200000000;
set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;

from 
(
    select imei,first_day,last_day,start_day
    from isubject.dwd_dvc_active_chain 
    where start_day &lt;= ${date-2} and end_day &gt; ${date-2}
)t1
full join(
    select imei from isubject.dwd_dvc_active_di	
    where date=${date-1}
    group by imei
)t2 
on t1.did = t2.did

insert overwrite table isubject.dwd_dvc_active_chain partition(end_day=20991231)
select
coalesce(t2.imei,t1.imei) as imei,
coalesce(t1.first_day,${date-1}) as first_day,
if(isnotnull(t2.imei),${date-1},t1.last_day) as last_day,
if(isnotnull(t2.imei),${date-1},t1.start_day) as start_day,
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') as etl_tm
distribute by rand()

insert overwrite table isubject.dwd_dvc_active_chain partition(end_day=${date-1})
select 
t1.imei,
t1.first_day,
t1.last_day,
t1.start_day as start_day,
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') as etl_tm
where  t1.imei is not null and  t2.imei is not null
distribute by rand()
;
</code></pre>

<p><strong>如果是配置表有可能需要保存删除状态，表需要增加字段del_flg，拉链表SQL如下</strong></p>

<p>表名:isubject.dwd_dvc_active_chain
|序号|字段|字段类型|字段描述|
| ——– | :—–:| :—-:|:—-:|
|1|imei|STRING|imei|
|2|del_flg|STRING|del_flg|
|3|app_ver|STRING|App_版本|
|4|model|STRING|model|
|5|first_day|BIGINT|创建时间|
|6|last_day|BIGINT|修改时间|
|7|etl_tm|STRING|etl_tm|
|8|start_day|BIGINT|start_day|</p>

<pre><code class="language-SQL">--全量拉链
from 
(
    select imei,first_day,last_day,start_day
    from isubject.dwd_dvc_active_chain 
    where start_day &lt;= ${date-2} and end_day &gt; ${date-2}
)t1
full join(
    select imei,0 as del_flg,app_ver,model from isubject.dwd_dvc_active_di	
    where date=${date-1}
    group by imei
    --这个地方需要保证imei是唯一主键 才能做拉链 
)t2 
on t1.did = t2.did

insert overwrite table isubject.dwd_dvc_active_chain partition(end_day=20991231) --最新的数据 包含删除的数据
select
coalesce(t2.imei,t1.imei) as imei,
coalesce(t2.del_flg,1),
coalesce(t2.app_ver,t1.app_ver) as app_ver,
coalesce(t2.model,t1.model) as model,
coalesce(t1.first_day,${date-1}) as first_day,
if(isnotnull(t2.imei),${date-1},t1.last_day) as last_day,
IF(
    (t1.del_flg =1 and t2.imei IS NULL) 
    OR (t1.imei=t2.imei and 
    coalesce(t1.app_ver,0)=coalesce(t2.app_ver,0) and
     coalesce(t1.model,0)=coalesce(t2.model,0)
    ),
    t1.start_day,${date-1}
    ) AS start_day,
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') as etl_tm
distribute by rand()

insert overwrite table isubject.dwd_dvc_active_chain partition(end_day=${date-1}) --历史${date-1}天的数据,不包含${date-1}天前删除的数据
select 
t1.imei,
t1.del_flg,
t1.app_ver,
t1.model,
t1.first_day,
t1.last_day,
t1.start_day as start_day,
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') as etl_tm
where  t1.imei is not null 
AND
( (t2.imei is null and t1.del_flg=0 ) or 
  (t2.imei is not null and (
    coalesce(t1.app_ver,0)&lt;&gt;coalesce(t2.app_ver,0) or
    coalesce(t1.model,0)&lt;&gt;coalesce(t2.model,0)
    ))
) 
distribute by rand()
;
</code></pre>]]></content><author><name></name></author><category term="bigdata" /><summary type="html"><![CDATA[大数据时代，如何进行数仓建模]]></summary></entry><entry><title type="html">数仓规范指南</title><link href="https://myyyy.github.io/blog/2022/%E6%95%B0%E4%BB%93%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/" rel="alternate" type="text/html" title="数仓规范指南" /><published>2022-10-22T00:00:00+00:00</published><updated>2022-10-22T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2022/%E6%95%B0%E4%BB%93%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97</id><content type="html" xml:base="https://myyyy.github.io/blog/2022/%E6%95%B0%E4%BB%93%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/"><![CDATA[<h3 id="引用">引用</h3>
<ol>
  <li><a href="https://www.cnblogs.com/itlz/p/15539258.html">数仓规范指南</a></li>
  <li><a href="https://mp.weixin.qq.com/s/9YR2FBfo1ufyF2G-M-JNhQ">美团数据平台及数仓建设实践，超十万字总结</a></li>
</ol>]]></content><author><name></name></author><category term="bigdata" /><summary type="html"><![CDATA[引用 数仓规范指南 美团数据平台及数仓建设实践，超十万字总结]]></summary></entry><entry><title type="html">docker入门</title><link href="https://myyyy.github.io/blog/2017/docker%E5%85%A5%E9%97%A8/" rel="alternate" type="text/html" title="docker入门" /><published>2017-03-17T00:00:00+00:00</published><updated>2017-03-17T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2017/docker%E5%85%A5%E9%97%A8</id><content type="html" xml:base="https://myyyy.github.io/blog/2017/docker%E5%85%A5%E9%97%A8/"><![CDATA[<p>#docker的环境配置</p>

<blockquote>
  <p>sudo apt-get update
sudo apt-get install docker.io</p>
</blockquote>

<p>#docker加速器配置</p>

<p>使用配置文件 /etc/docker/daemon.json（没有时新建该文件）
{
   “registry-mirrors”: [“<your accelerate="" address="">"]
}
注:基于阿里云的镜像加速</your></p>

<h1 id="下拉项目运行环境">下拉项目运行环境</h1>

<p>sudo docker pull registry.cn-hangzhou.aliyuncs.com/zhangxj/smartbow-web:0.2 
注:可跟你不同项目的需要配置不同的运行环境</p>

<p>#运行docker image</p>

<p>docker run –name web -ti registry.cn-hangzhou.aliyuncs.com/zhangxj/smartbow-web:0.2 bash</p>

<p>#编写脚本文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name:up.sh
#!/bin/bash
docker stop web
docker rm -v web

docker run --name web -ti -p 8887:8887 -p 8888:8888 -v /home/suyf/swork/git:/app registry.cn-hangzhou.aliyuncs.com/zhangxj/smartbow-web:0.2 bash
</code></pre></div></div>

<p>#命令</p>
<ol>
  <li>退出docker容器(非中断模式)
    <ul>
      <li>ctrl + P ctrl + q</li>
    </ul>
  </li>
  <li>进入docker image
    <ul>
      <li>docker exec -it container_id bash #不会终止</li>
      <li>docker attach <container> #需要注意的是，如果从这个stdin中exit，会导致容器的停止</container></li>
    </ul>
  </li>
  <li>检查容器运行
    <ul>
      <li>docker ps</li>
      <li>docker ps -a</li>
    </ul>
  </li>
  <li>查看容器信息
    <ul>
      <li>docker inspect <container></container></li>
    </ul>
  </li>
  <li>杀死or删除
    <ul>
      <li>docker stop <container></container></li>
      <li>docker kill <container></container></li>
      <li>docker rm <container></container></li>
      <li>docker rm $(docker ps -aq) #移除所有</li>
    </ul>
  </li>
</ol>

<p>#参考链接</p>
<blockquote>
  <p><a href="http://www.linuxidc.com/Linux/2015-05/117510.htm">docker命令简单介绍</a></p>
</blockquote>]]></content><author><name></name></author><category term="other" /><summary type="html"><![CDATA[docker的初步应用]]></summary></entry><entry><title type="html">Tornado设置默认403(error)页面</title><link href="https://myyyy.github.io/blog/2017/tornado%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4403(error)%E9%A1%B5%E9%9D%A2/" rel="alternate" type="text/html" title="Tornado设置默认403(error)页面" /><published>2017-03-17T00:00:00+00:00</published><updated>2017-03-17T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2017/tornado%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4403(error)%E9%A1%B5%E9%9D%A2</id><content type="html" xml:base="https://myyyy.github.io/blog/2017/tornado%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4403(error)%E9%A1%B5%E9%9D%A2/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span>
<span class="kn">import</span> <span class="n">tornado</span>
<span class="kn">import</span> <span class="n">tornado.options</span>
<span class="kn">import</span> <span class="n">tornado.httpserver</span>
<span class="kn">from</span> <span class="n">tornado.web</span> <span class="kn">import</span> <span class="n">RequestHandler</span>
<span class="kn">from</span> <span class="n">tornado.options</span> <span class="kn">import</span> <span class="n">define</span><span class="p">,</span> <span class="n">options</span>

<span class="nf">define</span><span class="p">(</span><span class="s">"port"</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1994</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s">"run on the given port"</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">BaseHandler</span><span class="p">(</span><span class="n">tornado</span><span class="p">.</span><span class="n">web</span><span class="p">.</span><span class="n">RequestHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">write_error</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">status_code</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">status_code</span> <span class="o">==</span> <span class="mi">403</span> <span class="ow">or</span> <span class="mi">405</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">dict</span><span class="p">(</span><span class="n">status</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
                <span class="n">data</span> <span class="o">=</span> <span class="s">'对不起，你没有权限访问该页面；如需帮助，请联系管理员 '</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">get_error_html</span><span class="p">(</span><span class="n">status_code</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_error_html</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">status_code</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">template_name</span> <span class="o">=</span> <span class="s">"{0}.html"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">status_code</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nf">exists</span><span class="p">(</span><span class="nf">template_path</span><span class="p">(</span><span class="n">template_name</span><span class="p">)):</span>
            <span class="n">template_name</span> <span class="o">=</span> <span class="s">"error.html"</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nf">exists</span><span class="p">(</span><span class="nf">template_path</span><span class="p">(</span><span class="n">template_name</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">status_code</span><span class="p">))</span>

        <span class="n">kwargs</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span>
            <span class="nf">dict</span><span class="p">(</span><span class="n">status_code</span><span class="o">=</span><span class="n">status_code</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">responses</span><span class="p">[</span><span class="n">status_code</span><span class="p">]))</span>

        <span class="n">self</span><span class="p">.</span><span class="nf">render</span><span class="p">(</span><span class="n">template_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">IndexHandler</span><span class="p">(</span><span class="n">BaseHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="s">'hello'</span><span class="p">)</span>

<span class="n">handlers</span> <span class="o">=</span> <span class="p">[</span> 
    <span class="p">(</span><span class="sa">r</span><span class="s">'/index'</span><span class="p">,</span> <span class="n">IndexHandler</span><span class="p">),</span>
    <span class="p">]</span>   

<span class="n">settings</span> <span class="o">=</span> <span class="p">{</span> 
        <span class="s">'template_path'</span><span class="p">:</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">),</span> <span class="s">"templates"</span><span class="p">),</span>
        <span class="s">'static_path'</span><span class="p">:</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">),</span> <span class="s">'static'</span><span class="p">),</span>
        <span class="p">}</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
        <span class="n">tornado</span><span class="p">.</span><span class="n">options</span><span class="p">.</span><span class="nf">parse_command_line</span><span class="p">()</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">tornado</span><span class="p">.</span><span class="n">web</span><span class="p">.</span><span class="nc">Application</span><span class="p">(</span><span class="n">handlers</span><span class="o">=</span><span class="n">handlers</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">)</span>
        <span class="n">http_server</span> <span class="o">=</span> <span class="n">tornado</span><span class="p">.</span><span class="n">httpserver</span><span class="p">.</span><span class="nc">HTTPServer</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
        <span class="n">http_server</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">port</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">port</span><span class="p">)</span>
        <span class="n">tornado</span><span class="p">.</span><span class="n">ioloop</span><span class="p">.</span><span class="n">IOLoop</span><span class="p">.</span><span class="nf">instance</span><span class="p">().</span><span class="nf">start</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="python" /><summary type="html"><![CDATA[``` python import os import tornado import tornado.options import tornado.httpserver from tornado.web import RequestHandler from tornado.options import define, options]]></summary></entry><entry><title type="html">Tornado源码解析之ioloop</title><link href="https://myyyy.github.io/blog/2017/Tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BIoLoop/" rel="alternate" type="text/html" title="Tornado源码解析之ioloop" /><published>2017-03-15T00:00:00+00:00</published><updated>2017-03-15T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2017/Tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BIoLoop</id><content type="html" xml:base="https://myyyy.github.io/blog/2017/Tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BIoLoop/"><![CDATA[<p>##预备知识</p>

<ol>
  <li>hasattr()&amp;getattr()
    <ul>
      <li>hasattr(object, name):判断一个对象是否有’name’属性或者’name’方法
 *getattr(object, name[,default]):获取对象object的属性或者方法，如果存在打印出来，如果不存在，打印出默认值，默认值可选。(如果获得的是方法,则返回的是方法的内存地址,有需要运行则需要加’()’)</li>
    </ul>
  </li>
  <li>classmethod &amp; staticmethod
    <ul>
      <li>待完善</li>
    </ul>
  </li>
  <li>future模块&amp;yeild
    <ul>
      <li>future:Python提供了__future__模块，把下一个新版本的特性导入到当前版本</li>
      <li>yeild: yield的英文单词意思是生产,若某个函数包含yield，这意味着这个函数已经是一个Generator<a href="http://www.pythontab.com/html/2015/pythonhexinbiancheng_0415/946.html">深入理解yield</a></li>
    </ul>
  </li>
  <li>python concurrent 模块
    <ul>
      <li>因python GIL全局锁的机制,产生了<a href="http://www.bubuko.com/infodetail-167068.html">concurrent</a>一个实现并发的模块</li>
    </ul>
  </li>
  <li>NotImplementedError()异常处理机制
    <ul>
      <li>NotImplemented 是一个非异常对象，NotImplementedError 是一个异常对象.<a href="http://www.tuicool.com/articles/JRb6Zr">参考链接</a>
 *<a href="https://segmentfault.com/q/1010000005012781">tornado 预定义接口返回异常的好处</a> 
 *<a href="https://blog.zorro.im/tornado-configurable/">tornado Configureable类</a></li>
    </ul>
  </li>
  <li>
    <p>Synchronous(同步)&amp;Asynchronous(异步)
 *理解概念<a href="http://www.cnblogs.com/anny0404/p/5691379.html">链接</a></p>
  </li>
  <li>
    <p>fileno()文件描述符
 *件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>

    <ul>
      <li>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统</li>
    </ul>
  </li>
  <li>double ckeck问题
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> if not hasattr(IOLoop, "_instance"):
 with IOLoop._instance_lock:
     if not hasattr(IOLoop, "_instance"):
         # New instance after double check
         IOLoop._instance = IOLoop()
</code></pre></div>    </div>

    <ul>
      <li><a href="http://www.jb51.net/article/80363.htm">torndao中单例模式的应用</a></li>
    </ul>
  </li>
  <li>select、poll、epoll
    <ul>
      <li><a href="Linux IO模式及 select、poll、epoll详解">Linux IO模式及 select、poll、epoll详解</a></li>
    </ul>
  </li>
</ol>]]></content><author><name></name></author><category term="python" /><summary type="html"><![CDATA[##预备知识]]></summary></entry><entry><title type="html">动态获取对象属性</title><link href="https://myyyy.github.io/blog/2016/%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95/" rel="alternate" type="text/html" title="动态获取对象属性" /><published>2016-10-19T00:00:00+00:00</published><updated>2016-10-19T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2016/%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95</id><content type="html" xml:base="https://myyyy.github.io/blog/2016/%E5%8A%A8%E6%80%81%E8%8E%B7%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95/"><![CDATA[<p>python 动态获取对象的属性和方法，并执行它们</p>

<p>首先通过一个例子来看一下本文中可能用到的对象和相关概念。</p>

<p>#coding: UTF-8</p>

<p>import sys #  模块，sys指向这个模块对象</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>import inspect

def foo(): pass # 函数，foo指向这个函数对象

class Cat(object): # 类，Cat指向这个类对象

def __init__(self, name='kitty'):

	self.name = name

def sayHi(self): #  实例方法，sayHi指向这个方法对象，使用类或实例.sayHi访问

	print self.name, 'says Hi!' # 访问名为name的字段，使用实例.name访问

	cat = Cat() # cat是Cat类的实例对象

	print Cat.sayHi # 使用类名访问实例方法时，方法是未绑定的(unbound)

	print cat.sayHi # 使用实例访问实例方法时，方法是绑定的(bound)
</code></pre></div></div>

<ul>
  <li>有时候我们会碰到这样的需求，需要执行对象的某个方法，或是需要对对象的某个字段赋值，而方法名或是字段名在编码代码时并不能确定，需要通过参数传递字符串的形式输入。举个具体的例子：当我们需要实现一个通用的DBM框架时，可能需要对数据对象的字段赋值，但我们无法预知用到这个框架的数据对象都有些什么字段，换言之，我们在写框架的时候需要通过某种机制访问未知的属性。这个机制被称为反射（反过来让对象告诉我们他是什么），或是自省（让对象自己告诉我们他是什么，好吧我承认括号里是我瞎掰的- -#），用于实现在运行时获取未知对象的信息。反射是个很吓唬人的名词，听起来高深莫测，在一般的编程语言里反射相对其他概念来说稍显复杂，一般来说都是作为高级主题来讲；但在Python中反射非常简单，用起来几乎感觉不到与其他的代码有区别，使用反射获取到的函数和方法可以像平常一样加上括号直接调用，获取到类后可以直接构造实例；不过获取到的字段不能直接赋值，因为拿到的其实是另一个指向同一个地方的引用，赋值只能改变当前的这个引用而已。</li>
</ul>

<p>#1. 访问对象的属性
以下列出了几个内建方法，可以用来检查或是访问对象的属性。这些方法可以用于任意对象而不仅仅是例子中的Cat实例对象；Python中一切都是对象。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cat = Cat('kitty')

print cat.name # 访问实例属性

cat.sayHi() # 调用实例方法

print dir(cat) # 获取实例的属性名，以列表形式返回

if hasattr(cat, 'name'): # 检查实例是否有这个属性

setattr(cat, 'name', 'tiger') # same as: a.name = 'tiger'

print getattr(cat, 'name') # same as: print a.name

getattr(cat, 'sayHi')() # same as: cat.sayHi()
</code></pre></div></div>

<p>dir([obj]): 
调用这个方法将返回包含obj大多数属性名的列表（会有一些特殊的属性不包含在内）。obj的默认值是当前的模块对象。
hasattr(obj, attr): 
这个方法用于检查obj是否有一个名为attr的值的属性，返回一个布尔值。
getattr(obj, attr): 
调用这个方法将返回obj中名为attr值的属性的值，例如如果attr为’bar’，则返回obj.bar。
setattr(obj, attr, val): 
调用这个方法将给obj的名为attr的值的属性赋值为val。例如如果attr为’bar’，则相当于obj.bar = val。
#2. 访问对象的元数据
	当你对一个你构造的对象使用dir()时，可能会发现列表中的很多属性并不是你定义的。这些属性一般保存了对象的元数据，比如类的__name__属性保存了类名。大部分这些属性都可以修改，不过改动它们意义并不是很大；修改其中某些属性如function.func_code还可能导致很难发现的问题，所以改改name什么的就好了，其他的属性不要在不了解后果的情况下修改。
	接下来列出特定对象的一些特殊属性。另外，Python的文档中有提到部分属性不一定会一直提供，下文中将以红色的星号*标记，使用前你可以先打开解释器确认一下。
	2.0. 准备工作：确定对象的类型
	在types模块中定义了全部的Python内置类型，结合内置方法isinstance()就可以确定对象的具体类型了。
	isinstance(object, classinfo): 
	检查object是不是classinfo中列举出的类型，返回布尔值。classinfo可以是一个具体的类型，也可以是多个类型的元组或列表。
	types模块中仅仅定义了类型，而inspect模块中封装了很多检查类型的方法，比直接使用types模块更为轻松，所以这里不给出关于types的更多介绍，如有需要可以直接查看types模块的文档说明。本文第3节中介绍了inspect模块。
##2.1. 模块(module)
	<strong>doc</strong>: 文档字符串。如果模块没有文档，这个值是None。
	*<strong>name</strong>: 始终是定义时的模块名；即使你使用import .. as 为它取了别名，或是赋值给了另一个变量名。
	*<strong>dict</strong>: 包含了模块里可用的属性名-属性的字典；也就是可以使用模块名.属性名访问的对象。
	<strong>file</strong>: 包含了该模块的文件路径。需要注意的是内建的模块没有这个属性，访问它会抛出异常！</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	import fnmatch as m

	print m.__doc__.splitlines()[0] # Filename matching with shell patterns.

	print m.__name__ # fnmatch

	print m.__file__ # /usr/lib/python2.6/fnmatch.pyc

	print m.__dict__.items()[0] # ('fnmatchcase', &lt;function fnmatchcase="" at="" 0xb73deb54=""&gt;)&lt;/function&gt;
</code></pre></div></div>

<p>##2.2. 类(class)
	<strong>doc</strong>: 文档字符串。如果类没有文档，这个值是None。
	*<strong>name</strong>: 始终是定义时的类名。
	*<strong>dict</strong>: 包含了类里可用的属性名-属性的字典；也就是可以使用类名.属性名访问的对象。
	<strong>module</strong>: 包含该类的定义的模块名；需要注意，是字符串形式的模块名而不是模块对象。
	*<strong>bases</strong>: 直接父类对象的元组；但不包含继承树更上层的其他类，比如父类的父类。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>print Cat.__doc__ # None

print Cat.__name__ # Cat

print Cat.__module__ # __main__

print Cat.__bases__ # (&lt;type ?object?=""&gt;,)

print Cat.__dict__ # {'__module__': '__main__', ...}&lt;/type&gt;

2.3. 实例(instance)
实例是指类实例化以后的对象。
*__dict__: 包含了可用的属性名-属性字典。
*__class__: 该实例的类对象。对于类Cat，cat.__class__ == Cat 为 True。

print cat.__dict__

print cat.__class__

print cat.__class__ == Cat # True
</code></pre></div></div>

<p>2.4. 内建函数和方法(built-in functions and methods)
根据定义，内建的(built-in)模块是指使用C写的模块，可以通过sys模块的builtin_module_names字段查看都有哪些模块是内建的。这些模块中的函数和方法可以使用的属性比较少，不过一般也不需要在代码中查看它们的信息。
<strong>doc</strong>: 函数或方法的文档。
<strong>name</strong>: 函数或方法定义时的名字。
<strong>self</strong>: 仅方法可用，如果是绑定的(bound)，则指向调用该方法的类（如果是类方法）或实例（如果是实例方法），否则为None。
*<strong>module</strong>: 函数或方法所在的模块名。
2.5. 函数(function)
这里特指非内建的函数。注意，在类中使用def定义的是方法，方法与函数虽然有相似的行为，但它们是不同的概念。
<strong>doc</strong>: 函数的文档；另外也可以用属性名func_doc。
<strong>name</strong>: 函数定义时的函数名；另外也可以用属性名func_name。
*<strong>module</strong>: 包含该函数定义的模块名；同样注意，是模块名而不是模块对象。
*<strong>dict</strong>: 函数的可用属性；另外也可以用属性名func_dict。 
不要忘了函数也是对象，可以使用函数.属性名访问属性（赋值时如果属性不存在将新增一个），或使用内置函数has/get/setattr()访问。不过，在函数中保存属性的意义并不大。
func_defaults: 这个属性保存了函数的参数默认值元组；因为默认值总是靠后的参数才有，所以不使用字典的形式也是可以与参数对应上的。
func_code: 这个属性指向一个该函数对应的code对象，code对象中定义了其他的一些特殊属性，将在下文中另外介绍。
func_globals: 这个属性指向当前的全局命名空间而不是定义函数时的全局命名空间，用处不大，并且是只读的。
*func_closure: 这个属性仅当函数是一个闭包时有效，指向一个保存了所引用到的外部函数的变量cell的元组，如果该函数不是一个内部函数，则始终为None。这个属性也是只读的。
下面的代码演示了func_closure：
01
#coding: UTF-8
02
def foo():
03
n = 1
04
def bar():
05
print n # 引用非全局的外部变量n，构造一个闭包
06
n = 2
07
return bar
08</p>

<p>09
closure = foo()
10
print closure.func_closure
11</p>
<h1 id="使用dir得知cell对象有一个cell_contents属性可以获得值">使用dir()得知cell对象有一个cell_contents属性可以获得值</h1>
<p>12
print closure.func_closure[0].cell_contents # 2</p>

<p>由这个例子可以看到，遇到未知的对象使用dir()是一个很好的主意 ：）
2.6. 方法(method)
方法虽然不是函数，但可以理解为在函数外面加了一层外壳；拿到方法里实际的函数以后，就可以使用2.5节的属性了。
<strong>doc</strong>: 与函数相同。
<strong>name</strong>: 与函数相同。
*<strong>module</strong>: 与函数相同。
im_func: 使用这个属性可以拿到方法里实际的函数对象的引用。另外如果是2.6以上的版本，还可以使用属性名__func__。
im_self: 如果是绑定的(bound)，则指向调用该方法的类（如果是类方法）或实例（如果是实例方法），否则为None。如果是2.6以上的版本，还可以使用属性名__self__。
im_class: 实际调用该方法的类，或实际调用该方法的实例的类。注意不是方法的定义所在的类，如果有继承关系的话。
1
im = cat.sayHi
2
print im.im_func
3
print im.im_self # cat
4
print im.im_class # Cat</p>

<p>这里讨论的是一般的实例方法，另外还有两种特殊的方法分别是类方法(classmethod)和静态方法(staticmethod)。类方法还是方法，不过因为需要使用类名调用，所以他始终是绑定的；而静态方法可以看成是在类的命名空间里的函数（需要使用类名调用的函数），它只能使用函数的属性，不能使用方法的属性。
2.7. 生成器(generator)
生成器是调用一个生成器函数(generator function)返回的对象，多用于集合对象的迭代。
<strong>iter</strong>: 仅仅是一个可迭代的标记。
gi_code: 生成器对应的code对象。
gi_frame: 生成器对应的frame对象。
gi_running: 生成器函数是否在执行。生成器函数在yield以后、执行yield的下一行代码前处于frozen状态，此时这个属性的值为0。
next|close|send|throw: 这是几个可调用的方法，并不包含元数据信息，如何使用可以查看生成器的相关文档。
01
def gen():
02
for n in xrange(5):
03
yield n
04
g = gen()
05
print g # &lt;generator object gen at 0x…&gt;
06
print g.gi_code # &lt;code object gen at 0x…&gt;
07
print g.gi_frame # &lt;frame object at 0x…&gt;
08
print g.gi_running # 0
09
print g.next() # 0
10
print g.next() # 1
11
for n in g:
12
print n, # 2 3 4</p>

<p>接下来讨论的是几个不常用到的内置对象类型。这些类型在正常的编码过程中应该很少接触，除非你正在自己实现一个解释器或开发环境之类。所以这里只列出一部分属性，如果需要一份完整的属性表或想进一步了解，可以查看文末列出的参考文档。
2.8. 代码块(code)
代码块可以由类源代码、函数源代码或是一个简单的语句代码编译得到。这里我们只考虑它指代一个函数时的情况；2.5节中我们曾提到可以使用函数的func_code属性获取到它。code的属性全部是只读的。
co_argcount: 普通参数的总数，不包括<em>参数和<strong>参数。
co_names: 所有的参数名（包括*参数和</strong>参数）和局部变量名的元组。
co_varnames: 所有的局部变量名的元组。
co_filename: 源代码所在的文件名。
co_flags:  这是一个数值，每一个二进制位都包含了特定信息。较关注的是0b100(0×4)和0b1000(0×8)，如果co_flags &amp; 0b100 != 0，说明使用了</em>args参数；如果co_flags &amp; 0b1000 != 0，说明使用了**kwargs参数。另外，如果co_flags &amp; 0b100000(0×20) != 0，则说明这是一个生成器函数(generator function)。
1
co = cat.sayHi.func_code
2
print co.co_argcount # 1
3
print co.co_names # (‘name’,)
4
print co.co_varnames # (‘self’,)
5
print co.co_flags &amp; 0b100 # 0</p>

<p>2.9. 栈帧(frame)
栈帧表示程序运行时函数调用栈中的某一帧。函数没有属性可以获取它，因为它在函数调用时才会产生，而生成器则是由函数调用返回的，所以有属性指向栈帧。想要获得某个函数相关的栈帧，则必须在调用这个函数且这个函数尚未返回时获取。你可以使用sys模块的_getframe()函数、或inspect模块的currentframe()函数获取当前栈帧。这里列出来的属性全部是只读的。
f_back: 调用栈的前一帧。
f_code: 栈帧对应的code对象。
f_locals: 用在当前栈帧时与内建函数locals()相同，但你可以先获取其他帧然后使用这个属性获取那个帧的locals()。
f_globals: 用在当前栈帧时与内建函数globals()相同，但你可以先获取其他帧……。
1
def add(x, y=1):
2
f = inspect.currentframe()
3
print f.f_locals # same as locals()
4
print f.f_back # &lt;frame object at 0x…&gt;
5
return x+y
6
add(2)</p>

<p>2.10. 追踪(traceback)
追踪是在出现异常时用于回溯的对象，与栈帧相反。由于异常时才会构建，而异常未捕获时会一直向外层栈帧抛出，所以需要使用try才能见到这个对象。你可以使用sys模块的exc_info()函数获得它，这个函数返回一个元组，元素分别是异常类型、异常对象、追踪。traceback的属性全部是只读的。
tb_next: 追踪的下一个追踪对象。
tb_frame: 当前追踪对应的栈帧。
tb_lineno: 当前追踪的行号。
1
def div(x, y):
2
try:
3
return x/y
4
except:
5
tb = sys.exc_info()[2] # return (exc_type, exc_value, traceback)
6
print tb
7
print tb.tb_lineno # “return x/y” 的行号
8
div(1, 0)</p>

<ol>
  <li>使用inspect模块
inspect模块提供了一系列函数用于帮助使用自省。下面仅列出较常用的一些函数，想获得全部的函数资料可以查看inspect模块的文档。
3.1. 检查对象类型
is{module|class|function|method|builtin}(obj): 
检查对象是否为模块、类、函数、方法、内建函数或方法。
isroutine(obj): 
用于检查对象是否为函数、方法、内建函数或方法等等可调用类型。用这个方法会比多个is<em>()更方便，不过它的实现仍然是用了多个is</em>()。 
1
im = cat.sayHi
2
if inspect.isroutine(im):
3
im()</li>
</ol>

<p>对于实现了__call__的类实例，这个方法会返回False。如果目的是只要可以直接调用就需要是True的话，不妨使用isinstance(obj, collections.Callable)这种形式。我也不知道为什么Callable会在collections模块中，抱歉！我猜大概是因为collections模块中包含了很多其他的ABC(Abstract Base Class)的缘故吧：）</p>

<p>3.2. 获取对象信息
getmembers(object[, predicate]): 
这个方法是dir()的扩展版，它会将dir()找到的名字对应的属性一并返回，形如[(name, value), …]。另外，predicate是一个方法的引用，如果指定，则应当接受value作为参数并返回一个布尔值，如果为False，相应的属性将不会返回。使用is*作为第二个参数可以过滤出指定类型的属性。
getmodule(object): 
还在为第2节中的__module__属性只返回字符串而遗憾吗？这个方法一定可以满足你，它返回object的定义所在的模块对象。
get{file|sourcefile}(object): 
获取object的定义所在的模块的文件名|源代码文件名（如果没有则返回None）。用于内建的对象（内建模块、类、函数、方法）上时会抛出TypeError异常。
get{source|sourcelines}(object): 
获取object的定义的源代码，以字符串|字符串列表返回。代码无法访问时会抛出IOError异常。只能用于module/class/function/method/code/frame/traceack对象。
getargspec(func): 
仅用于方法，获取方法声明的参数，返回元组，分别是(普通参数名的列表, *参数名, **参数名, 默认值元组)。如果没有值，将是空列表和3个None。如果是2.6以上版本，将返回一个命名元组(Named Tuple)，即除了索引外还可以使用属性名访问元组中的元素。<br />
1
def add(x, y=1, *z):
2
return x + y + sum(z)
3
print inspect.getargspec(add)
4
#ArgSpec(args=[‘x’, ‘y’], varargs=’z’, keywords=None, defaults=(1,))</p>

<p>getargvalues(frame): 
仅用于栈帧，获取栈帧中保存的该次函数调用的参数值，返回元组，分别是(普通参数名的列表, *参数名, **参数名, 帧的locals())。如果是2.6以上版本，将返回一个命名元组(Named Tuple)，即除了索引外还可以使用属性名访问元组中的元素。
1
def add(x, y=1, *z):
2
print inspect.getargvalues(inspect.currentframe())
3
return x + y + sum(z)
4
add(2)
5
#ArgInfo(args=[‘x’, ‘y’], varargs=’z’, keywords=None, locals={‘y’: 1, ‘x’: 2, ‘z’: ()})</p>

<p>getcallargs(func[, *args][, **kwds]): 
返回使用args和kwds调用该方法时各参数对应的值的字典。这个方法仅在2.7版本中才有。
getmro(cls): 
返回一个类型元组，查找类属性时按照这个元组中的顺序。如果是新式类，与cls.<strong>mro__结果一样。但旧式类没有__mro__这个属性，直接使用这个属性会报异常，所以这个方法还是有它的价值的。 
1
print inspect.getmro(Cat)
2
#(&lt;class ‘__main</strong>.Cat’&gt;, &lt;type ‘object’&gt;)
3
print Cat.<strong>mro</strong>
4
#(&lt;class ‘<strong>main</strong>.Cat’&gt;, &lt;type ‘object’&gt;)python 动态获取对象的属性和方法，并执行它们
By admin ( 三月 2, 2011 at 10:58 下午) · Filed under 编程, python, 反射, 自省</p>

<p>首先通过一个例子来看一下本文中可能用到的对象和相关概念。
01
#coding: UTF-8
02
import sys #  模块，sys指向这个模块对象
03
import inspect
04
def foo(): pass # 函数，foo指向这个函数对象
05</p>

<p>06
class Cat(object): # 类，Cat指向这个类对象
07
def <strong>init</strong>(self, name=’kitty’):
08
self.name = name
09
def sayHi(self): #  实例方法，sayHi指向这个方法对象，使用类或实例.sayHi访问
10
print self.name, ‘says Hi!’ # 访问名为name的字段，使用实例.name访问
11</p>

<p>12
cat = Cat() # cat是Cat类的实例对象
13</p>

<p>14
print Cat.sayHi # 使用类名访问实例方法时，方法是未绑定的(unbound)
15
print cat.sayHi # 使用实例访问实例方法时，方法是绑定的(bound)</p>

<p>有时候我们会碰到这样的需求，需要执行对象的某个方法，或是需要对对象的某个字段赋值，而方法名或是字段名在编码代码时并不能确定，需要通过参数传递字符串的形式输入。举个具体的例子：当我们需要实现一个通用的DBM框架时，可能需要对数据对象的字段赋值，但我们无法预知用到这个框架的数据对象都有些什么字段，换言之，我们在写框架的时候需要通过某种机制访问未知的属性。
这个机制被称为反射（反过来让对象告诉我们他是什么），或是自省（让对象自己告诉我们他是什么，好吧我承认括号里是我瞎掰的- -#），用于实现在运行时获取未知对象的信息。反射是个很吓唬人的名词，听起来高深莫测，在一般的编程语言里反射相对其他概念来说稍显复杂，一般来说都是作为高级主题来讲；但在Python中反射非常简单，用起来几乎感觉不到与其他的代码有区别，使用反射获取到的函数和方法可以像平常一样加上括号直接调用，获取到类后可以直接构造实例；不过获取到的字段不能直接赋值，因为拿到的其实是另一个指向同一个地方的引用，赋值只能改变当前的这个引用而已。</p>
<ol>
  <li>访问对象的属性
以下列出了几个内建方法，可以用来检查或是访问对象的属性。这些方法可以用于任意对象而不仅仅是例子中的Cat实例对象；Python中一切都是对象。
01
cat = Cat(‘kitty’)
02</li>
</ol>

<p>03
print cat.name # 访问实例属性
04
cat.sayHi() # 调用实例方法
05</p>

<p>06
print dir(cat) # 获取实例的属性名，以列表形式返回
07
if hasattr(cat, ‘name’): # 检查实例是否有这个属性
08
setattr(cat, ‘name’, ‘tiger’) # same as: a.name = ‘tiger’
09
print getattr(cat, ‘name’) # same as: print a.name
10</p>

<p>11
getattr(cat, ‘sayHi’)() # same as: cat.sayHi()</p>

<p>dir([obj]): 
调用这个方法将返回包含obj大多数属性名的列表（会有一些特殊的属性不包含在内）。obj的默认值是当前的模块对象。
hasattr(obj, attr): 
这个方法用于检查obj是否有一个名为attr的值的属性，返回一个布尔值。
getattr(obj, attr): 
调用这个方法将返回obj中名为attr值的属性的值，例如如果attr为’bar’，则返回obj.bar。
setattr(obj, attr, val): 
调用这个方法将给obj的名为attr的值的属性赋值为val。例如如果attr为’bar’，则相当于obj.bar = val。</p>
<ol>
  <li>访问对象的元数据
当你对一个你构造的对象使用dir()时，可能会发现列表中的很多属性并不是你定义的。这些属性一般保存了对象的元数据，比如类的__name__属性保存了类名。大部分这些属性都可以修改，不过改动它们意义并不是很大；修改其中某些属性如function.func_code还可能导致很难发现的问题，所以改改name什么的就好了，其他的属性不要在不了解后果的情况下修改。
接下来列出特定对象的一些特殊属性。另外，Python的文档中有提到部分属性不一定会一直提供，下文中将以红色的星号*标记，使用前你可以先打开解释器确认一下。
2.0. 准备工作：确定对象的类型
在types模块中定义了全部的Python内置类型，结合内置方法isinstance()就可以确定对象的具体类型了。
isinstance(object, classinfo): 
检查object是不是classinfo中列举出的类型，返回布尔值。classinfo可以是一个具体的类型，也可以是多个类型的元组或列表。
types模块中仅仅定义了类型，而inspect模块中封装了很多检查类型的方法，比直接使用types模块更为轻松，所以这里不给出关于types的更多介绍，如有需要可以直接查看types模块的文档说明。本文第3节中介绍了inspect模块。
2.1. 模块(module)
<strong>doc</strong>: 文档字符串。如果模块没有文档，这个值是None。
*<strong>name</strong>: 始终是定义时的模块名；即使你使用import .. as 为它取了别名，或是赋值给了另一个变量名。
*<strong>dict</strong>: 包含了模块里可用的属性名-属性的字典；也就是可以使用模块名.属性名访问的对象。
<strong>file</strong>: 包含了该模块的文件路径。需要注意的是内建的模块没有这个属性，访问它会抛出异常！
1
import fnmatch as m
2
print m.<strong>doc</strong>.splitlines()[0] # Filename matching with shell patterns.
3
print m.<strong>name</strong> # fnmatch
4
print m.<strong>file</strong> # /usr/lib/python2.6/fnmatch.pyc
5
print m.<strong>dict</strong>.items()[0] # (‘fnmatchcase’, &lt;function fnmatchcase=”” at=”” 0xb73deb54=””&gt;)&lt;/function&gt;</li>
</ol>

<p>2.2. 类(class)
<strong>doc</strong>: 文档字符串。如果类没有文档，这个值是None。
*<strong>name</strong>: 始终是定义时的类名。
*<strong>dict</strong>: 包含了类里可用的属性名-属性的字典；也就是可以使用类名.属性名访问的对象。
<strong>module</strong>: 包含该类的定义的模块名；需要注意，是字符串形式的模块名而不是模块对象。
*<strong>bases</strong>: 直接父类对象的元组；但不包含继承树更上层的其他类，比如父类的父类。
1
print Cat.<strong>doc</strong> # None
2
print Cat.<strong>name</strong> # Cat
3
print Cat.<strong>module</strong> # <strong>main</strong>
4
print Cat.<strong>bases</strong> # (&lt;type ?object?=””&gt;,)
5
print Cat.<strong>dict</strong> # {‘<strong>module</strong>’: ‘<strong>main</strong>’, …}&lt;/type&gt;</p>

<p>2.3. 实例(instance)
实例是指类实例化以后的对象。
*<strong>dict</strong>: 包含了可用的属性名-属性字典。
*<strong>class</strong>: 该实例的类对象。对于类Cat，cat.<strong>class</strong> == Cat 为 True。
1
print cat.<strong>dict</strong>
2
print cat.<strong>class</strong>
3
print cat.<strong>class</strong> == Cat # True</p>

<p>2.4. 内建函数和方法(built-in functions and methods)
根据定义，内建的(built-in)模块是指使用C写的模块，可以通过sys模块的builtin_module_names字段查看都有哪些模块是内建的。这些模块中的函数和方法可以使用的属性比较少，不过一般也不需要在代码中查看它们的信息。
<strong>doc</strong>: 函数或方法的文档。
<strong>name</strong>: 函数或方法定义时的名字。
<strong>self</strong>: 仅方法可用，如果是绑定的(bound)，则指向调用该方法的类（如果是类方法）或实例（如果是实例方法），否则为None。
*<strong>module</strong>: 函数或方法所在的模块名。
2.5. 函数(function)
这里特指非内建的函数。注意，在类中使用def定义的是方法，方法与函数虽然有相似的行为，但它们是不同的概念。
<strong>doc</strong>: 函数的文档；另外也可以用属性名func_doc。
<strong>name</strong>: 函数定义时的函数名；另外也可以用属性名func_name。
*<strong>module</strong>: 包含该函数定义的模块名；同样注意，是模块名而不是模块对象。
*<strong>dict</strong>: 函数的可用属性；另外也可以用属性名func_dict。 
不要忘了函数也是对象，可以使用函数.属性名访问属性（赋值时如果属性不存在将新增一个），或使用内置函数has/get/setattr()访问。不过，在函数中保存属性的意义并不大。
func_defaults: 这个属性保存了函数的参数默认值元组；因为默认值总是靠后的参数才有，所以不使用字典的形式也是可以与参数对应上的。
func_code: 这个属性指向一个该函数对应的code对象，code对象中定义了其他的一些特殊属性，将在下文中另外介绍。
func_globals: 这个属性指向当前的全局命名空间而不是定义函数时的全局命名空间，用处不大，并且是只读的。
*func_closure: 这个属性仅当函数是一个闭包时有效，指向一个保存了所引用到的外部函数的变量cell的元组，如果该函数不是一个内部函数，则始终为None。这个属性也是只读的。
下面的代码演示了func_closure：
01
#coding: UTF-8
02
def foo():
03
n = 1
04
def bar():
05
print n # 引用非全局的外部变量n，构造一个闭包
06
n = 2
07
return bar
08</p>

<p>09
closure = foo()
10
print closure.func_closure
11</p>
<h1 id="使用dir得知cell对象有一个cell_contents属性可以获得值-1">使用dir()得知cell对象有一个cell_contents属性可以获得值</h1>
<p>12
print closure.func_closure[0].cell_contents # 2</p>

<p>由这个例子可以看到，遇到未知的对象使用dir()是一个很好的主意 ：）
2.6. 方法(method)
方法虽然不是函数，但可以理解为在函数外面加了一层外壳；拿到方法里实际的函数以后，就可以使用2.5节的属性了。
<strong>doc</strong>: 与函数相同。
<strong>name</strong>: 与函数相同。
*<strong>module</strong>: 与函数相同。
im_func: 使用这个属性可以拿到方法里实际的函数对象的引用。另外如果是2.6以上的版本，还可以使用属性名__func__。
im_self: 如果是绑定的(bound)，则指向调用该方法的类（如果是类方法）或实例（如果是实例方法），否则为None。如果是2.6以上的版本，还可以使用属性名__self__。
im_class: 实际调用该方法的类，或实际调用该方法的实例的类。注意不是方法的定义所在的类，如果有继承关系的话。
1
im = cat.sayHi
2
print im.im_func
3
print im.im_self # cat
4
print im.im_class # Cat</p>

<p>这里讨论的是一般的实例方法，另外还有两种特殊的方法分别是类方法(classmethod)和静态方法(staticmethod)。类方法还是方法，不过因为需要使用类名调用，所以他始终是绑定的；而静态方法可以看成是在类的命名空间里的函数（需要使用类名调用的函数），它只能使用函数的属性，不能使用方法的属性。
2.7. 生成器(generator)
生成器是调用一个生成器函数(generator function)返回的对象，多用于集合对象的迭代。
<strong>iter</strong>: 仅仅是一个可迭代的标记。
gi_code: 生成器对应的code对象。
gi_frame: 生成器对应的frame对象。
gi_running: 生成器函数是否在执行。生成器函数在yield以后、执行yield的下一行代码前处于frozen状态，此时这个属性的值为0。
next|close|send|throw: 这是几个可调用的方法，并不包含元数据信息，如何使用可以查看生成器的相关文档。
01
def gen():
02
for n in xrange(5):
03
yield n
04
g = gen()
05
print g # &lt;generator object gen at 0x…&gt;
06
print g.gi_code # &lt;code object gen at 0x…&gt;
07
print g.gi_frame # &lt;frame object at 0x…&gt;
08
print g.gi_running # 0
09
print g.next() # 0
10
print g.next() # 1
11
for n in g:
12
print n, # 2 3 4</p>

<p>接下来讨论的是几个不常用到的内置对象类型。这些类型在正常的编码过程中应该很少接触，除非你正在自己实现一个解释器或开发环境之类。所以这里只列出一部分属性，如果需要一份完整的属性表或想进一步了解，可以查看文末列出的参考文档。
2.8. 代码块(code)
代码块可以由类源代码、函数源代码或是一个简单的语句代码编译得到。这里我们只考虑它指代一个函数时的情况；2.5节中我们曾提到可以使用函数的func_code属性获取到它。code的属性全部是只读的。
co_argcount: 普通参数的总数，不包括<em>参数和<strong>参数。
co_names: 所有的参数名（包括*参数和</strong>参数）和局部变量名的元组。
co_varnames: 所有的局部变量名的元组。
co_filename: 源代码所在的文件名。
co_flags:  这是一个数值，每一个二进制位都包含了特定信息。较关注的是0b100(0×4)和0b1000(0×8)，如果co_flags &amp; 0b100 != 0，说明使用了</em>args参数；如果co_flags &amp; 0b1000 != 0，说明使用了**kwargs参数。另外，如果co_flags &amp; 0b100000(0×20) != 0，则说明这是一个生成器函数(generator function)。
1
co = cat.sayHi.func_code
2
print co.co_argcount # 1
3
print co.co_names # (‘name’,)
4
print co.co_varnames # (‘self’,)
5
print co.co_flags &amp; 0b100 # 0</p>

<p>2.9. 栈帧(frame)
栈帧表示程序运行时函数调用栈中的某一帧。函数没有属性可以获取它，因为它在函数调用时才会产生，而生成器则是由函数调用返回的，所以有属性指向栈帧。想要获得某个函数相关的栈帧，则必须在调用这个函数且这个函数尚未返回时获取。你可以使用sys模块的_getframe()函数、或inspect模块的currentframe()函数获取当前栈帧。这里列出来的属性全部是只读的。
f_back: 调用栈的前一帧。
f_code: 栈帧对应的code对象。
f_locals: 用在当前栈帧时与内建函数locals()相同，但你可以先获取其他帧然后使用这个属性获取那个帧的locals()。
f_globals: 用在当前栈帧时与内建函数globals()相同，但你可以先获取其他帧……。
1
def add(x, y=1):
2
f = inspect.currentframe()
3
print f.f_locals # same as locals()
4
print f.f_back # &lt;frame object at 0x…&gt;
5
return x+y
6
add(2)</p>

<p>2.10. 追踪(traceback)
追踪是在出现异常时用于回溯的对象，与栈帧相反。由于异常时才会构建，而异常未捕获时会一直向外层栈帧抛出，所以需要使用try才能见到这个对象。你可以使用sys模块的exc_info()函数获得它，这个函数返回一个元组，元素分别是异常类型、异常对象、追踪。traceback的属性全部是只读的。
tb_next: 追踪的下一个追踪对象。
tb_frame: 当前追踪对应的栈帧。
tb_lineno: 当前追踪的行号。
1
def div(x, y):
2
try:
3
return x/y
4
except:
5
tb = sys.exc_info()[2] # return (exc_type, exc_value, traceback)
6
print tb
7
print tb.tb_lineno # “return x/y” 的行号
8
div(1, 0)</p>

<ol>
  <li>使用inspect模块
inspect模块提供了一系列函数用于帮助使用自省。下面仅列出较常用的一些函数，想获得全部的函数资料可以查看inspect模块的文档。
3.1. 检查对象类型
is{module|class|function|method|builtin}(obj): 
检查对象是否为模块、类、函数、方法、内建函数或方法。
isroutine(obj): 
用于检查对象是否为函数、方法、内建函数或方法等等可调用类型。用这个方法会比多个is<em>()更方便，不过它的实现仍然是用了多个is</em>()。 
1
im = cat.sayHi
2
if inspect.isroutine(im):
3
im()</li>
</ol>

<p>对于实现了__call__的类实例，这个方法会返回False。如果目的是只要可以直接调用就需要是True的话，不妨使用isinstance(obj, collections.Callable)这种形式。我也不知道为什么Callable会在collections模块中，抱歉！我猜大概是因为collections模块中包含了很多其他的ABC(Abstract Base Class)的缘故吧：）</p>

<p>3.2. 获取对象信息
getmembers(object[, predicate]): 
这个方法是dir()的扩展版，它会将dir()找到的名字对应的属性一并返回，形如[(name, value), …]。另外，predicate是一个方法的引用，如果指定，则应当接受value作为参数并返回一个布尔值，如果为False，相应的属性将不会返回。使用is*作为第二个参数可以过滤出指定类型的属性。
getmodule(object): 
还在为第2节中的__module__属性只返回字符串而遗憾吗？这个方法一定可以满足你，它返回object的定义所在的模块对象。
get{file|sourcefile}(object): 
获取object的定义所在的模块的文件名|源代码文件名（如果没有则返回None）。用于内建的对象（内建模块、类、函数、方法）上时会抛出TypeError异常。
get{source|sourcelines}(object): 
获取object的定义的源代码，以字符串|字符串列表返回。代码无法访问时会抛出IOError异常。只能用于module/class/function/method/code/frame/traceack对象。
getargspec(func): 
仅用于方法，获取方法声明的参数，返回元组，分别是(普通参数名的列表, *参数名, **参数名, 默认值元组)。如果没有值，将是空列表和3个None。如果是2.6以上版本，将返回一个命名元组(Named Tuple)，即除了索引外还可以使用属性名访问元组中的元素。<br />
1
def add(x, y=1, *z):
2
return x + y + sum(z)
3
print inspect.getargspec(add)
4
#ArgSpec(args=[‘x’, ‘y’], varargs=’z’, keywords=None, defaults=(1,))</p>

<p>getargvalues(frame): 
仅用于栈帧，获取栈帧中保存的该次函数调用的参数值，返回元组，分别是(普通参数名的列表, *参数名, **参数名, 帧的locals())。如果是2.6以上版本，将返回一个命名元组(Named Tuple)，即除了索引外还可以使用属性名访问元组中的元素。
1
def add(x, y=1, *z):
2
print inspect.getargvalues(inspect.currentframe())
3
return x + y + sum(z)
4
add(2)
5
#ArgInfo(args=[‘x’, ‘y’], varargs=’z’, keywords=None, locals={‘y’: 1, ‘x’: 2, ‘z’: ()})</p>

<p>getcallargs(func[, *args][, **kwds]): 
返回使用args和kwds调用该方法时各参数对应的值的字典。这个方法仅在2.7版本中才有。
getmro(cls): 
返回一个类型元组，查找类属性时按照这个元组中的顺序。如果是新式类，与cls.<strong>mro__结果一样。但旧式类没有__mro__这个属性，直接使用这个属性会报异常，所以这个方法还是有它的价值的。 
1
print inspect.getmro(Cat)
2
#(&lt;class ‘__main</strong>.Cat’&gt;, &lt;type ‘object’&gt;)
3
print Cat.<strong>mro</strong>
4
#(&lt;class ‘<strong>main</strong>.Cat’&gt;, &lt;type ‘object’&gt;)
5
class Dog: pass
6
print inspect.getmro(Dog)
7
#(&lt;class <strong>main</strong>.Dog at 0x…&gt;,)
8
print Dog.<strong>mro</strong> # AttributeError</p>

<p>currentframe(): 
返回当前的栈帧对象。
其他的操作frame和traceback的函数请查阅inspect模块的文档，用的比较少，这里就不多介绍了。
Permalink</p>

<p>Leave a Comment
5
class Dog: pass
6
print inspect.getmro(Dog)
7
#(&lt;class <strong>main</strong>.Dog at 0x…&gt;,)
8
print Dog.<strong>mro</strong> # AttributeError</p>

<p>currentframe(): 
返回当前的栈帧对象。
其他的操作frame和traceback的函数请查阅inspect模块的文档，用的比较少，这里就不多介绍了。</p>]]></content><author><name></name></author><category term="python" /><summary type="html"><![CDATA[python动态获取对象属性。]]></summary></entry><entry><title type="html">python pdb调试</title><link href="https://myyyy.github.io/blog/2016/python-pdb%E8%B0%83%E8%AF%95/" rel="alternate" type="text/html" title="python pdb调试" /><published>2016-05-21T00:00:00+00:00</published><updated>2016-05-21T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2016/python%20pdb%E8%B0%83%E8%AF%95</id><content type="html" xml:base="https://myyyy.github.io/blog/2016/python-pdb%E8%B0%83%E8%AF%95/"><![CDATA[<h2 id="在python中使用pdb模块可以进行调试">在python中使用pdb模块可以进行调试</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">pdb</span>
<span class="n">pdb</span><span class="p">.</span><span class="nf">set_trace</span><span class="p">()</span>
</code></pre></div></div>

<p>也可以使用python -m pdb mysqcript.py这样的方式</p>

<p>(Pdb) 会自动停在第一行，等待调试,这时你可以看看 帮助
(Pdb) h
    说明下这几个关键 命令</p>

<ul>
  <li>断点设置
 (Pdb)<code class="language-plaintext highlighter-rouge">b</code>  10 #断点设置在本py的第10行
 或(Pdb)b  ots.py:20 #断点设置到 ots.py第20行
 删除断点（Pdb）b #查看断点编号
          (Pdb)cl 2 #删除第2个断点</li>
  <li>运行
  (Pdb)n #单步运行
  (Pdb)s #细点运行 也就是会下到，方法
  (Pdb)<code class="language-plaintext highlighter-rouge">c</code> #跳到下个断点</li>
  <li>查看
  (Pdb)<code class="language-plaintext highlighter-rouge">p</code> param #查看当前 变量值
  (Pdb)l #查看运行到某处代码
  (Pdb)a #查看全部栈内变量
  (Pdb)w 列出目前call stack 中的所在层。
  (Pdb)d 在call stack中往下移一层
  (Pdb)u 在call stack中往上移一层。如果在上移一层之后按下 n ,则会在上移之后的一层执行下一个叙述,之前的 function call 就自动返回。
  (Pdb)cl 清除指定的断点。如果没有带参数,则清除所有断点。
  (Pdb)disable 取消所有断点的功能,但仍然保留这些断点。
  (Pdb)enable 恢复断点的功能。
  (Pdb)ignore 设定断点的忽略次数。如果没指定 count,其初始 为 0。当 count 为 0 时,断点会正常动作。若有指定 count,则每次执行到该中断, count 就少 1,直到 count 数为 0。
  (Pdb)condition bpnumber [condition]
  (Pdb)j(ump) lineNo. 跳到某行执行。只有在 call stack 的最底部才能作用。
  (Pdb)l  列出目前所在档案中的位置。连续地 l 命令会一直列到档案结尾,可以使用指定行数或范围来打印。
  (Pdb)pp 和 p 命令类似,但是使用 pprint module(没用过 pprint,详情请参考 Python Library Reference)。
  (Pdb)alias 以一个”别名”代替”一群除错命令”,有点类似 c/c++ 的 macro(详情请参考 Python Library Reference)。
  (Pdb)unalias 取消某个 alias。
  (Pdb)[!]statement 在目前的环境(context)中执行叙述。</li>
</ul>]]></content><author><name></name></author><category term="python" /><summary type="html"><![CDATA[an example of a blog post with giscus comments]]></summary></entry></feed>