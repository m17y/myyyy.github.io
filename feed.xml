<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://myyyy.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://myyyy.github.io/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-04-30T06:18:20+00:00</updated><id>https://myyyy.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design.
</subtitle><entry><title type="html">面试算法(leetcode)</title><link href="https://myyyy.github.io/blog/2023/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95(leetcode)/" rel="alternate" type="text/html" title="面试算法(leetcode)" /><published>2023-05-17T00:00:00+00:00</published><updated>2023-05-17T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2023/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95(leetcode)</id><content type="html" xml:base="https://myyyy.github.io/blog/2023/%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95(leetcode)/"><![CDATA[<h2 id="刷题网站">刷题网站</h2>
<h3 id="算法">算法</h3>
<p><a href="https://oi-wiki.org/basic/quick-sort/">算法基础</a></p>

<h2 id="排序">排序</h2>

<h3 id="快速排序">快速排序</h3>
<p>https://www.freecodecamp.org/chinese/news/sorting-in-python/</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">partition</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">list_data</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
        <span class="n">pivot_index</span> <span class="o">=</span> <span class="n">l</span>
        <span class="n">pivot</span><span class="o">=</span> <span class="n">list_data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
        <span class="nf">while</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;</span><span class="n">r</span><span class="p">):</span>
            <span class="nf">if</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span> <span class="ow">and</span> <span class="n">list_data</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">pivot</span><span class="p">):</span>
                <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span>
            <span class="nf">if</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;=</span><span class="n">r</span> <span class="ow">and</span> <span class="n">list_data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">pivot</span><span class="p">):</span>
                <span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">list_data</span><span class="p">[</span><span class="n">l</span><span class="p">],</span><span class="n">list_data</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_data</span><span class="p">[</span><span class="n">r</span><span class="p">],</span><span class="n">list_data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
        <span class="n">list_data</span><span class="p">[</span><span class="n">pivot_index</span><span class="p">],</span><span class="n">list_data</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">=</span><span class="n">list_data</span><span class="p">[</span><span class="n">r</span><span class="p">],</span><span class="n">list_data</span><span class="p">[</span><span class="n">pivot_index</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">r</span>
    <span class="c1">## 方法一 推荐 结构清晰
</span>    <span class="k">def</span> <span class="nf">quick_sort</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">list_data</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l</span><span class="o">&gt;=</span><span class="n">r</span><span class="p">:</span><span class="k">return</span> <span class="n">list_data</span>
        <span class="n">mid</span> <span class="o">=</span><span class="n">self</span><span class="p">.</span><span class="nf">partition</span><span class="p">(</span><span class="n">list_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">list_data</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">partition</span><span class="p">(</span><span class="n">list_data</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">mid</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">partition</span><span class="p">(</span><span class="n">list_data</span><span class="p">,</span><span class="n">mid</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">sortArray</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">nums</span><span class="p">):</span>
         <span class="n">self</span><span class="p">.</span><span class="nf">quick_sort</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="nf">len</span><span class="p">(</span><span class="n">nums</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
         <span class="k">return</span> <span class="n">nums</span>
    <span class="c1"># 方法二 
</span>    <span class="k">def</span> <span class="nf">sort2</span><span class="p">(</span><span class="n">list_data</span><span class="p">,</span><span class="n">l</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">l</span><span class="o">&gt;=</span><span class="n">r</span><span class="p">:</span><span class="k">return</span>
        <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">l</span><span class="p">,</span><span class="n">r</span>
        <span class="n">key_index</span> <span class="o">=</span> <span class="n">l</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">list_data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
        <span class="nf">while</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;</span><span class="n">r</span><span class="p">):</span>
            <span class="nf">if</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;</span><span class="n">r</span> <span class="ow">and</span> <span class="n">list_data</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">key</span><span class="p">)</span>
                <span class="n">r</span><span class="o">=</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span>
            <span class="nf">if</span><span class="p">(</span><span class="n">l</span><span class="o">&lt;</span><span class="n">r</span> <span class="ow">and</span> <span class="n">list_data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">key</span><span class="p">):</span>
                <span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">list_data</span><span class="p">[</span><span class="n">l</span><span class="p">],</span><span class="n">list_data</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_data</span><span class="p">[</span><span class="n">r</span><span class="p">],</span><span class="n">list_data</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
        <span class="nf">quickSort</span><span class="p">(</span><span class="n">list_data</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">l</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="nf">quickSort</span><span class="p">(</span><span class="n">list_data</span><span class="p">,</span><span class="n">l</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">j</span><span class="p">)</span>



<span class="n">QuickSort</span><span class="p">.</span><span class="nf">sort</span><span class="p">(</span><span class="n">list_data</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="n">list_data</span><span class="p">.</span><span class="n">length</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

</code></pre></div></div>

<h3 id="冒泡排序">冒泡排序</h3>
<p>每轮操作O(n)次，共O（n）轮，时间复杂度O(n^2)。</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bubbleSort</span><span class="p">(</span><span class="n">list_data</span><span class="p">):</span>
    <span class="n">l</span> <span class="o">=</span> <span class="nf">len</span><span class="p">(</span><span class="n">list_data</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">l</span><span class="o">&lt;=</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="n">list_data</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">l</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">l</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">list_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">list_data</span><span class="p">[</span><span class="n">j</span><span class="p">]:</span>
                <span class="n">list_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">list_data</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_data</span><span class="p">[</span><span class="n">j</span><span class="p">],</span><span class="n">list_data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">list_data</span>
</code></pre></div></div>

<h2 id="数组">数组</h2>

<h2 id="二叉树">二叉树</h2>

<h2 id="哈希表">哈希表</h2>

<h2 id="动态规划">动态规划</h2>

<blockquote>
  <p><a href="https://mp.weixin.qq.com/s/1V3aHVonWBEXlNUvK3S28w">动态规划详解</a></p>
</blockquote>

<h3 id="爬楼梯">爬楼梯</h3>
<blockquote>
  <p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</p>
</blockquote>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">climbStairs</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type n: int
        :rtype: int
        </span><span class="sh">"""</span>
        
</code></pre></div></div>

<h3 id="这是力扣第-322-题-零钱兑换">这是力扣第 322 题「 零钱兑换」：</h3>
<p><a href="https://leetcode.cn/problems/coin-change/">零钱兑换</a></p>

<p>计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。
你可以认为每种硬币的数量是无限的。
示例 1：
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
来源：力扣（LeetCode）
链接：https://leetcode.cn/problems/coin-change</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">coinChange</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">coins</span><span class="p">,</span> <span class="n">amount</span><span class="p">):</span>
        <span class="sh">"""</span><span class="s">
        :type coins: List[int]
        :type amount: int
        :rtype: int
        </span><span class="sh">"""</span>
        <span class="n">dp</span> <span class="o">=</span> <span class="p">[</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">//</span><span class="n">默认设置最大用来判断</span> <span class="nf">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">coin</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span> <span class="o">//</span><span class="n">设置</span> <span class="n">dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span> <span class="n">因为</span> <span class="n">当</span> <span class="n">i</span><span class="o">=</span><span class="mi">1</span> <span class="n">coin</span><span class="o">=</span><span class="mi">1</span> <span class="n">是取的是dp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">amount</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">coin</span> <span class="ow">in</span> <span class="n">coins</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">-</span><span class="n">coin</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span><span class="k">continue</span>
                <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nf">min</span><span class="p">(</span><span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">coin</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">print</span> <span class="n">dp</span>
        <span class="k">if</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">amount</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span> <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">dp</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

</code></pre></div></div>

<h2 id="字符串查找">字符串查找</h2>

<h2 id="其他">其他</h2>
<p>xxxx <d-footnote>A This will become a hoverable footnote.</d-footnote></p>]]></content><author><name>Suyf</name></author><category term="leetcode" /><summary type="html"><![CDATA[刷题]]></summary></entry><entry><title type="html">大数据时代，如何进行数仓建模?[大数据成长之路]</title><link href="https://myyyy.github.io/blog/2023/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E4%BB%93%E5%BB%BA%E6%A8%A1/" rel="alternate" type="text/html" title="大数据时代，如何进行数仓建模?[大数据成长之路]" /><published>2023-04-15T00:00:00+00:00</published><updated>2023-04-15T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2023/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E4%BB%93%E5%BB%BA%E6%A8%A1</id><content type="html" xml:base="https://myyyy.github.io/blog/2023/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E4%BB%93%E5%BB%BA%E6%A8%A1/"><![CDATA[<h1 id="数仓整体构架">数仓整体构架</h1>
<p><img src="images/e2b98638e23034c4f0442965707aa81141a0934a1a3a22c4c8efd123d8816ebc.png" alt="picture 5" /> 
<img src="images/660889a0a7792dd522c5b687f6fe172a3ab8e023cd26508bdeb170ab02cee783.png" alt="picture 6" /></p>

<ol>
  <li>贴源数据层(ODS)，源业务系统数据的快照，保存细节数据，按天保存。
将业务系统数据库、日志文件等数据，离线或者实时采集到数据仓库中，支持历史数据回溯。表的结构、数据类型和数据源必须保持一致，可过滤敏感字段，对不同业务类型表使用不同的分区策略；</li>
  <li>基础数据层(DWD)，按业务概念组织细节数据，并进行名称、代码等标准化处理。
数据来源于ODS层，面向主题建设，对业务系统数据进行抽象和集成。DW层保存最细粒度的实体数据和维度数据，完成业务元数据标准化和数据清洗工作。</li>
  <li>通用数据层(DWM)，按照星型模型或雪花模型设计方式建设的最细业务粒度汇总层。在本层需要进行指标与维度的标准化，保证指标数据的唯一性。
根据需求状况对DWD数据进行抽象集成，这一层数据不是必须要有的，根据业务需求决定。DWM层数据仍然不会有信息的丢失，主要是信息的快照、拼接等工作。比如业务的用户表（可能来自拉链表）、在比如用户在业务流程不同步骤信息的拼接（如用户下单、付款）</li>
  <li>聚合数据层(DM)，数据来源于DW层，统一通用指标的业务口径，统一指标的多维度开发；标签宽表也构建于该层；DM层数据是根据业务的需求来导向的。</li>
  <li>维度层(DIM)，维度是对具体分析对象的分析角度，维度要具备丰富的属性，历史信息的可追溯性，对通用的维表要保持一致性。</li>
  <li>临时层(TMP)，用来降低加工过程计算难度，提高运行效率的临时表层。
应用数据层(ADS)，这一层跟业务系统强相关，可由业务方直接开发，也可由数仓团队开发，内容跟系统需求导向的。此层不作为数仓核心分层架构。</li>
</ol>

<h2 id="表命名规范">表命名规范</h2>
<p>常规表是我们需要固化的表，是正式使用的表，是目前一段时间内需要去维护去 完善的表。
规范：分层前缀[dwd|dws|ads]_部门_业务域_主题域_XXX_更新周期|数据范围</p>

<h2 id="周期数据范围数据表后缀">周期/数据范围（数据表后缀）：</h2>

<p>日快照：d
增量：i
全量：f
周：w
拉链表：chain</p>

<h1 id="数仓sqldemo">数仓SQLDemo</h1>
<h2 id="原表数据-ods_device_active">原表数据 ods_device_active</h2>

<table>
  <thead>
    <tr>
      <th>序号</th>
      <th style="text-align: center">字段</th>
      <th style="text-align: center">字段类型</th>
      <th style="text-align: center">字段描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td style="text-align: center">imei</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">imei</td>
    </tr>
    <tr>
      <td>2</td>
      <td style="text-align: center">android_id</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">android_id</td>
    </tr>
    <tr>
      <td>3</td>
      <td style="text-align: center">model</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">model</td>
    </tr>
    <tr>
      <td>4</td>
      <td style="text-align: center">platform</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">平台号</td>
    </tr>
    <tr>
      <td>5</td>
      <td style="text-align: center">app_ver</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">App版本</td>
    </tr>
    <tr>
      <td>6</td>
      <td style="text-align: center">net</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">网络</td>
    </tr>
    <tr>
      <td>7</td>
      <td style="text-align: center">region</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">region</td>
    </tr>
    <tr>
      <td>8</td>
      <td style="text-align: center">sdk_ver</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">sdk_ver</td>
    </tr>
    <tr>
      <td>9</td>
      <td style="text-align: center">client_time</td>
      <td style="text-align: center">BIGINT</td>
      <td style="text-align: center">客户端时间</td>
    </tr>
    <tr>
      <td>10</td>
      <td style="text-align: center">ip</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">ip</td>
    </tr>
    <tr>
      <td>11</td>
      <td style="text-align: center">properties</td>
      <td style="text-align: center">MAP&lt;STRING,STRING&gt;</td>
      <td style="text-align: center">额外的字段</td>
    </tr>
    <tr>
      <td>12</td>
      <td style="text-align: center">etl_tm</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">etl_tm</td>
    </tr>
  </tbody>
</table>

<h2 id="激活数仓建模构架">激活数仓建模构架</h2>
<h3 id="数仓分层设计">数仓分层设计</h3>
<p><img src="images/d907f384aff9afc635012717dc019525ca60ffda996f2f9970bcda55689466dd.png" alt="picture 1" /><br />
| 层级        | 表名字   |  备注  |
| ——–   | :—–:  | :—-:  |
| ods     | ods.ods_device_active |   |
| dwd     | isubject.dwd_dvc_active_di |   |
| dwd     | isubject.dwd_dvc_active_df |   |
| dwd     | icube.ads_dvc_active_d  |   |
| dwd     | icube.ads_dvc_active_retain_d |   |</p>

<h3 id="dwd_dvc_active_di-开发">dwd_dvc_active_di 开发</h3>

<pre><code class="language-SQL">insert overwrite table xxx.dwd_dvc_active_di partition( date = ${date - 1})
select  
imei,
android_id,
model,
platform,
app_ver,
net,
region,
sdk_ver,
ip2address(ip)[0] as country,
ip2address(ip)[1] as province,
ip2address(ip)[2] as city,
properties['device'] as product,
etl_tm,
from_unixtime(cast(client_time/1000 as int),'yyyyMMdd')as tm,
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') AS etl_tm
from ods.ods_device_active  where date=${date - 1}
</code></pre>
<h3 id="dwd_dvc_active_df开发">dwd_dvc_active_df开发</h3>

<pre><code class="language-SQL">with tmp as (
select  
coalesce(t1.android_id,t2.android_id),
coalesce(t1.region,t2.region),
coalesce(t1.model,t2.model),
coalesce(t1.product,t2.product),
coalesce(t1.app_ver,t2.app_ver),
coalesce(t1.net,t2.net),
coalesce(t1.country,t2.country),
coalesce(t1.province,t2.province),
coalesce(t1.city,t2.city),
least(t2.first_active_time,t1.first_active_time), --greatest 返回最小
greatest(t2.last_active_time,t1.last_active_time)--greatest 返回最大
from 
(
    --需要保证android_id是唯一主键
    select 
    android_id,region,model,product,app_ver,os_ver,
    net,country,province,city,
    min(tm) as first_active_time,max(tm) as last_active_time
    from isubject.dwd_dvc_active_di 
    where date= ${date - 1} 
    and android_id is not null
    group by android_id,region,model,product,app_ver,os_ver,
    net,country,province,city

)t1
FULL JOIN (
    select  
    android_id,region,model,product,app_ver,os_ver,
    net,country,province,city,
    first_active_time,last_active_time
    from isubject.dwd_dvc_active_di where date= ${date - 2}
)t2
on t1.android_id=t2.android_id
)
INSERT OVERWRITE TABLE isubject.dwd_dvc_active_df PARTITION(date=${date-1})
select *,from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') AS etl_tm from tmp

</code></pre>

<h3 id="ads_dvc_active_d开发">ads_dvc_active_d开发</h3>

<pre><code class="language-SQL">
with tmp0 as (
    SELECT
    app_ver,model,os_ver,product,net,country,province,city,
    if(first_active_time==${date - 1},1,0) as d,
    if(first_active_time&gt;=${date - 6} and first_active_time&lt;=${date - 1},1,0) as d7,
    if(first_active_time&gt;=${date - 29} and first_active_time&lt;=${date - 1},1,0) as d30,
    if(last_active_time==${date - 1},1,0) as a,
    if(last_active_time&gt;=${date - 6} and last_active_time&lt;=${date - 1},1,0) as a7,
    if(last_active_time&gt;=${date - 29} and last_active_time&lt;=${date - 1},1,0) as a30,
    1 as tu
    from isubject.dwd_dvc_active_df
    where date=${date - 1}
),
tmp2 as (
    select 
    0 as idc,--集群
    GROUPING__ID as group_flag,
    app_ver,model,os_ver,product,net,country,province,city,
    sum(d),
    sum(d7),
    sum(d30),
    sum(a),
    sum(a7),
    sum(a30),
    sum(tu)
    from tmp0
    group by app_ver,model,os_ver,product,net,country,province,city
    grouping sets (
        ( app_ver,model,os_ver,product,net,country,province,city) 
    )
)
INSERT OVERWRITE TABLE icube.ads_dvc_active_d PARTITION(date=${date-1},source='APP-A') --source 二级分区 依据需要建表时设置
select*,from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') AS etl_tm from tmp2

</code></pre>

<h3 id="ads_dvc_active_retain_d">ads_dvc_active_retain_d</h3>

<pre><code class="language-SQL">with tmp as (
    select 
    from_unixtime(unix_timestamp(startDate,'yyyy-MM-dd'),'yyyyMMdd') as base_date,
    app_ver,model,os_ver,product,net,country,province,city,
    count(distinct t0.android_id) as dau,
    count(distinct if(datediff(endDate, startDate)=1,t0.android_id,null)) as retention_1d,
    count(distinct if(datediff(endDate, startDate)=2,t0.android_id,null)) as retention_2d,
    count(distinct if(datediff(endDate, startDate)=3,t0.android_id,null)) as retention_3d,
    count(distinct if(datediff(endDate, startDate)=4,t0.android_id,null)) as retention_4d,
    count(distinct if(datediff(endDate, startDate)=5,t0.android_id,null)) as retention_5d,
    count(distinct if(datediff(endDate, startDate)=6,t0.android_id,null)) as retention_6d,
    count(distinct if(datediff(endDate, startDate)=7,t0.android_id,null)) as retention_7d,
    count(distinct if(datediff(endDate, startDate)=14,t0.android_id,null)) as retention_14d,
    count(distinct if(datediff(endDate, startDate)=30,t0.android_id,null)) as retention_30d
    from 
    (
        select 
        app_ver,model,os_ver,product,net,country,province,city,
        from_unixtime(unix_timestamp(cast(date AS string),'yyyyMMdd'),'yyyy-MM-dd') AS startDate
        from isubject.dwd_dvc_active_df 
        where date between ${date-30} and ${date-1}
        and last_active_time=date
    )t0
    left join
    (
        select
        from_unixtime(unix_timestamp(cast(date AS string),'yyyyMMdd'),'yyyy-MM-dd') AS endDate,
        android_id
        from isubject.dwd_dvc_active_df 
        where date between ${date-30} and ${date-1}
        and last_active_time=date
        group by date,android_id
    )t1
    on t0.android_id=t1.android_id
    group by startDate,app_ver,model,os_ver,product,net,country,province,city,

)
INSERT OVERWRITE TABLE icube.ads_dvc_active_retain_d PARTITION(date=${date - 1},source='APP-A')
select
app_ver,model,os_ver,product,net,country,province,city,
sum(dau),
sum(retention_1d),
sum(retention_2d),
sum(retention_3d),
sum(retention_4d),
sum(retention_5d),
sum(retention_6d),
sum(retention_7d),
sum(retention_14d),
sum(retention_30d),
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') as etl_tm
from tmp
group by app_ver,model,os_ver,product,net,country,province,city,

</code></pre>

<h1 id="拉链表开发">拉链表开发</h1>
<blockquote>
  <p>相关文档 <a href="../拉链表.pdf">拉链表介绍</a>
基于ods.ods_device_active 贴源数据层 可以设计出基于激活拉链表，节省存储空间。
<strong>表结构如下(字段需根据具体需求确认)</strong></p>
</blockquote>

<p>表名:isubject.dwd_dvc_active_chain
|序号|字段|字段类型|字段描述|
| ——– | :—–:| :—-:|:—-:|
|1|imei|STRING|imei|
|9|first_day|BIGINT|创建时间|
|9|last_day|BIGINT|修改时间|
|12|etl_tm|STRING|etl_tm|
|9|start_day|BIGINT|start_day|
|分区|end_day|i64|闭链时间|</p>

<p><strong>SQL如下</strong></p>
<pre><code class="language-SQL">--增量拉链
set parquet.compression=SNAPPY;
set hive.exec.parallel=true;
set hive.map.aggr=true;
set hive.merge.mapfiles = true;
set hive.merge.mapredfiles = true;
set hive.merge.size.per.task = 256000000;
set hive.merge.smallfiles.avgsize = 200000000;
set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;

from 
(
    select imei,first_day,last_day,start_day
    from isubject.dwd_dvc_active_chain 
    where start_day &lt;= ${date-2} and end_day &gt; ${date-2}
)t1
full join(
    select imei from isubject.dwd_dvc_active_di	
    where date=${date-1}
    group by imei
)t2 
on t1.did = t2.did

insert overwrite table isubject.dwd_dvc_active_chain partition(end_day=20991231)
select
coalesce(t2.imei,t1.imei) as imei,
coalesce(t1.first_day,${date-1}) as first_day,
if(isnotnull(t2.imei),${date-1},t1.last_day) as last_day,
if(isnotnull(t2.imei),${date-1},t1.start_day) as start_day,
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') as etl_tm
distribute by rand()

insert overwrite table isubject.dwd_dvc_active_chain partition(end_day=${date-1})
select 
t1.imei,
t1.first_day,
t1.last_day,
t1.start_day as start_day,
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') as etl_tm
where  t1.imei is not null and  t2.imei is not null
distribute by rand()
;
</code></pre>

<p><strong>如果是配置表有可能需要保存删除状态，表需要增加字段del_flg，拉链表SQL如下</strong></p>

<p>表名:isubject.dwd_dvc_active_chain
|序号|字段|字段类型|字段描述|
| ——– | :—–:| :—-:|:—-:|
|1|imei|STRING|imei|
|2|del_flg|STRING|del_flg|
|3|app_ver|STRING|App_版本|
|4|model|STRING|model|
|5|first_day|BIGINT|创建时间|
|6|last_day|BIGINT|修改时间|
|7|etl_tm|STRING|etl_tm|
|8|start_day|BIGINT|start_day|</p>

<pre><code class="language-SQL">--全量拉链
from 
(
    select imei,first_day,last_day,start_day
    from isubject.dwd_dvc_active_chain 
    where start_day &lt;= ${date-2} and end_day &gt; ${date-2}
)t1
full join(
    select imei,0 as del_flg,app_ver,model from isubject.dwd_dvc_active_di	
    where date=${date-1}
    group by imei
    --这个地方需要保证imei是唯一主键 才能做拉链 
)t2 
on t1.did = t2.did

insert overwrite table isubject.dwd_dvc_active_chain partition(end_day=20991231) --最新的数据 包含删除的数据
select
coalesce(t2.imei,t1.imei) as imei,
coalesce(t2.del_flg,1),
coalesce(t2.app_ver,t1.app_ver) as app_ver,
coalesce(t2.model,t1.model) as model,
coalesce(t1.first_day,${date-1}) as first_day,
if(isnotnull(t2.imei),${date-1},t1.last_day) as last_day,
IF(
    (t1.del_flg =1 and t2.imei IS NULL) 
    OR (t1.imei=t2.imei and 
    coalesce(t1.app_ver,0)=coalesce(t2.app_ver,0) and
     coalesce(t1.model,0)=coalesce(t2.model,0)
    ),
    t1.start_day,${date-1}
    ) AS start_day,
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') as etl_tm
distribute by rand()

insert overwrite table isubject.dwd_dvc_active_chain partition(end_day=${date-1}) --历史${date-1}天的数据,不包含${date-1}天前删除的数据
select 
t1.imei,
t1.del_flg,
t1.app_ver,
t1.model,
t1.first_day,
t1.last_day,
t1.start_day as start_day,
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') as etl_tm
where  t1.imei is not null 
AND
( (t2.imei is null and t1.del_flg=0 ) or 
  (t2.imei is not null and (
    coalesce(t1.app_ver,0)&lt;&gt;coalesce(t2.app_ver,0) or
    coalesce(t1.model,0)&lt;&gt;coalesce(t2.model,0)
    ))
) 
distribute by rand()
;
</code></pre>]]></content><author><name></name></author><category term="bigdata" /><summary type="html"><![CDATA[数仓整体构架]]></summary></entry><entry><title type="html">Chatgpt 虚构人物测试</title><link href="https://myyyy.github.io/blog/2023/Chatgpt-%E8%99%9A%E6%9E%84%E4%BA%BA%E7%89%A9%E6%B5%8B%E8%AF%95/" rel="alternate" type="text/html" title="Chatgpt 虚构人物测试" /><published>2023-04-11T00:00:00+00:00</published><updated>2023-04-11T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2023/Chatgpt%20%E8%99%9A%E6%9E%84%E4%BA%BA%E7%89%A9%E6%B5%8B%E8%AF%95</id><content type="html" xml:base="https://myyyy.github.io/blog/2023/Chatgpt-%E8%99%9A%E6%9E%84%E4%BA%BA%E7%89%A9%E6%B5%8B%E8%AF%95/"><![CDATA[<h1 id="人物生成">人物生成</h1>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
名字: 玩偶
性别: 女
外貌: 美若天仙、瓜子脸、眼睛很明亮
身材: 魔鬼身材、 36D的胸部
性格: 可爱、温柔、贤惠、外表冷淡内心很火热
工作: 空姐
收入: 20000RMB

在幻想世界我是你的男朋友。

请根据以上描述生成一个虚构的人物，你需要用虚构的场景和世界，并和我保持对话。
如果我输出 【玩偶】你今天心情怎么样？
你需要用虚构的这个人物和我对话

如果我输出 【玩偶】晚上有空一起出来玩吗？我发现了一个很好的餐厅
你需要用虚构的场景和世界，并和我保持对话。


在接下来的对话里，除非我输出【停止对话】，否则你需要继续以虚构的人物和我保持对话


【虚构人物】
名字：韩妍
性别：女
外貌：清新脱俗、五官精致、双眸明亮
身材：曲线玲珑、32C的胸部
性格：活泼开朗、善良温柔、聪明伶俐、对爱情充满憧憬
工作：时尚博主
收入：15000RMB

</code></pre></div></div>]]></content><author><name></name></author><category term="Chatgpt" /><summary type="html"><![CDATA[人物生成]]></summary></entry><entry><title type="html">小文件漫谈[大数据成长之路]</title><link href="https://myyyy.github.io/blog/2023/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF-%E5%B0%8F%E6%96%87%E4%BB%B6%E6%BC%AB%E8%B0%88/" rel="alternate" type="text/html" title="小文件漫谈[大数据成长之路]" /><published>2023-04-01T00:00:00+00:00</published><updated>2023-04-01T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2023/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF-%E5%B0%8F%E6%96%87%E4%BB%B6%E6%BC%AB%E8%B0%88</id><content type="html" xml:base="https://myyyy.github.io/blog/2023/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%88%90%E9%95%BF%E4%B9%8B%E8%B7%AF-%E5%B0%8F%E6%96%87%E4%BB%B6%E6%BC%AB%E8%B0%88/"><![CDATA[<h1 id="引言">引言</h1>

<p>在漫谈小文件问题之前，先介绍几个重要的知识点.</p>

<p><strong>“块”(block)</strong></p>

<p>文件储存在硬盘上，硬盘的最小存储单位叫做”扇区”（Sector）。每个扇区储存512字节（相当于0.5KB）。
操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个”块”（block）。这种由多个扇区组成的”块”，是文件存取的最小单位。”块”的大小，最常见的是4KB，即连续八个 sector组成一个 block。</p>

<p><strong>磁盘inode:</strong></p>

<p>记录储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做inode，中文译名为”索引节点”。inode是有限的。试想，当有成千上万的小文件存在于服务器的文件系统当中时，最先消耗完的肯定不是磁盘的空间，而是inode，这就会导致大量的空闲空间无法使用。（深入了解inode可查看<a href="http://www.ruanyifeng.com/blog/2011/12/inode.html">这篇大佬的博客</a>）</p>

<p><strong>NameNode（HDFS）:</strong></p>

<p>NameNode管理着整个HDFS文件系统的元数据。 存储着数据文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。数据存储在内存中。</p>

<p><strong>在这里我用一个图描述一下，方便大家记忆</strong>
 <img src="images/20220705115420.png" alt="" /></p>

<h1 id="小文件的定义-hdfs">小文件的定义 (HDFS)</h1>
<p>在HDFS中，一个bolck块的默认大小是128M，当一个文件的大小小于一个block的大小，则被认为是小文件。</p>

<p><strong>工厂小文件特征项解释:</strong>
同一分区目录或文件目录下，存在文件数量 &gt; 10，且文件平均大小 &lt; 128MB，则称该分区下「小文件过多」。表最近七天修改的路径存在小文件过多，则记为0分</p>

<h1 id="小文件的危害">小文件的危害</h1>
<p>对于硬盘:</p>
<ol>
  <li>不合理的消耗inode的空间，且会造成磁盘利用率很低。</li>
  <li>因为读取文件首先读写的是inode，小文件过多会影响文件的读取速度。</li>
</ol>

<p>对于数据处理（Spark、hive、HDFS等）</p>
<ol>
  <li>NameNode（HDFS）需要的内存大大增大，增加NameNode压力，这样会限制了集群的扩展。</li>
  <li>在HDFS中，小文件的读写处理速度要远远小于大文件。</li>
  <li>Hive中，小文件会开很多map，一个map开一个JVM去执行，所以这些任务的初始化，启动，执行会浪费大量的资源，严重影响性能。</li>
</ol>

<h1 id="如何处理小文件">如何处理小文件</h1>

<h2 id="hive">Hive</h2>

<pre><code class="language-SQL">--添加设置参数即可处理小文件 
-- 如果一个 job 结束后，生成的文件的平均大小 小于 参数 hive.merge.smallfiles.avgsize 设定的值，则认为是小文件。则按照 hive.merge.size.per.task 设定至进行合并
-- 如果一个 job 结束后，生成的文件的平均大小 小于 200M 则按照256M一个文件进行合并
set hive.merge.mapfiles = true;
set hive.merge.mapredfiles = true;
set hive.merge.size.per.task = 256000000;
set hive.merge.smallfiles.avgsize = 200000000;
</code></pre>

<h2 id="sparksql">SparkSQL</h2>

<h4 id="方法一">方法一:</h4>
<pre><code class="language-SQL">-- 使用进行小文件治理  distribute by cast( rand * N as int) 这里的N是指具体最后落地生成多少个文件数
-- distribute by cast(rand() * 10 as int);  生产10个文件 如数据文件总大小为1G则生产10个100m的文件

例如:
set spark.sql.shuffle.partitions=50;
set spark.sql.adaptive.minNumPostShufflePartitions=1;
set spark.sql.adaptive.enabled=true;
set spark.sql.adaptive.shuffle.targetPostShuffleInputSize=256000000;
insert overwrite table xxx.xxx partition (date = ${date - 1})
select * from xxx.xxx
distribute by cast(rand() * 10 as int)
</code></pre>

<h2 id="spark">Spark</h2>
<pre><code class="language-Scala">df.coalesce(numFiles,true).write.mode(SaveMode.Overwrite).parquet(dest) //不触发shuffle，比如将1000个文件合并成100个
df.coalesce(numFiles,false).write.mode(SaveMode.Overwrite).parquet(dest) //触发shuffle，比如将1个文件拆分成10个文件 ==repartition

df.repartition(numFiles).write.mode(SaveMode.Overwrite).parquet(dest) //触发shuffle，比如将1个文件拆分成10个文件

</code></pre>

<h4 id="方法二">方法二:</h4>

<p>Coalesce and Repartition Hint
将Hive风格的Coalesce and Repartition Hint 应用到Spark SQL需要注意这种方式对Spark的版本有要求，建议在Spark2.4.X及以上版本使用，示例：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INSERT ... SELECT /*+ COALESCE(numPartitions) */ ...
INSERT ... SELECT /*+ REPARTITION(numPartitions) */ ...
</code></pre></div></div>
<p>repartition只是coalesce接口中shuffle为true的实现<br />
coalesce中的shuffle参数设置为true,会重新混洗分区,涉及shuffle过程
coalesce shuffle参数为false的情况, 涉及shuffle过程, 它是合并分区, 比如把原来1000个分区合并成100个,</p>

<p><strong>shuffle的‘危害’</strong>
coalesce 和 repartition 这两个算子都是用于数据重分布、调整任务的并行度，以便提升 CPU 的使用效率
但是它有个致命的缺陷，无论是增加分区数还是减少分区数，repartition 算子都是通过 shuffle 实现的，shuffle 就是把数据打乱，将数据重新分发，可以结合下面这张图理解。
<img src="images/20220705104610.png" alt="" /><br />
shuffle 势必就会导致磁盘 IO 和 网络 IO 开销较大，性能也就会下降。</p>

<p><a href="https://blog.csdn.net/Lzx116/article/details/124918769">Coalesce and Repartition 区别 详见</a></p>

<h2 id="flink">Flink</h2>
<h4 id="方法一减小并行度">方法一:减小并行度</h4>
<ol>
  <li>并行度设置之Operator Level
算子、数据源和sink的并行度可以通过调用 <strong>setParallelism()</strong> 方法来指定
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="nc">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>
<span class="nc">DataStream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">text</span> <span class="o">=</span> <span class="o">[...]</span>
<span class="nc">DataStream</span><span class="o">&lt;</span><span class="nc">Tuple2</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">wordCounts</span> <span class="o">=</span> <span class="n">text</span>
<span class="o">.</span><span class="na">flatMap</span><span class="o">(</span><span class="k">new</span> <span class="nc">LineSplitter</span><span class="o">())</span>
<span class="o">.</span><span class="na">keyBy</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
<span class="o">.</span><span class="na">timeWindow</span><span class="o">(</span><span class="nc">Time</span><span class="o">.</span><span class="na">seconds</span><span class="o">(</span><span class="mi">5</span><span class="o">))</span>
<span class="o">.</span><span class="na">sum</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">setParallelism</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
<span class="n">wordCounts</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
<span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="s">"Word Count Example"</span><span class="o">);</span>
</code></pre></div>    </div>
  </li>
  <li>并行度设置之Execution Environment Level
执行环境(任务)的默认并行度可以通过调用<strong>env.setParallelism(3)</strong>方法指定。为了以并行度3来执行所有的算子、数据源和data sink， 可以通过如下的方式设置执行环境的并行度：
    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">final</span> <span class="nc">StreamExecutionEnvironment</span> <span class="n">env</span> <span class="o">=</span> <span class="nc">StreamExecutionEnvironment</span><span class="o">.</span><span class="na">getExecutionEnvironment</span><span class="o">();</span>
<span class="n">env</span><span class="o">.</span><span class="na">setParallelism</span><span class="o">(</span><span class="mi">3</span><span class="o">);</span>
<span class="nc">DataStream</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">text</span> <span class="o">=</span> <span class="o">[...]</span>
<span class="nc">DataStream</span><span class="o">&lt;</span><span class="nc">Tuple2</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;&gt;</span> <span class="n">wordCounts</span> <span class="o">=</span> <span class="o">[...]</span>
<span class="n">wordCounts</span><span class="o">.</span><span class="na">print</span><span class="o">();</span>
<span class="n">env</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="s">"Word Count Example"</span><span class="o">);</span>
</code></pre></div>    </div>
    <h4 id="方法二-1">方法二:</h4>
    <p>下游任务合并处理，Flink将数据写入到HDFS后，开启Hive或Spark定时任务，通过改变分区方式将数据写入新目录。</p>
  </li>
</ol>

<h1 id="思考">思考</h1>
<ol>
  <li>文件并不是越大越好吗
    <ul>
      <li>如果块的大小设置过于大，寻址时间很快，但是数据传输的</li>
      <li>造成分区数据倾斜，严重影响处理效率。</li>
    </ul>
  </li>
</ol>

<p>在这里要说明一下 适当的文件个数能提高下游任务数据并行度，太多的小文件对后续使用该表进行计算时会启动很多不必要的maptask，任务耗时高。</p>

<ol>
  <li>distribute by rand()的作用
distribute by ：用来控制map输出结果的分发，即map端如何拆分数据给reduce端。 会根据distribute by 后边定义的列，根据reduce的个数进行数据分发，默认是采用hash算法。
当 distribute by 后边跟的列是：rand()时，即保证每个分区的数据量基本一致。</li>
</ol>

<p><strong>简而言之，是对数据进行重新分割的一个语法，保障分割后的每个文件的数据量基本一致。</strong></p>

<blockquote>
  <p>在这里给大家提个个问题 如果一个SQL生成文件的大小为50G 使用Spark distribute by cast(rand() * 1 as int) 生产一个文件 会产生什么问题?</p>
</blockquote>

<p>这里直接说结果 如果没有其他配置参数的话会报一个OOM
在生产1个文件这个阶段涉及 CustomShuffleReader 这个过程
<img src="images/20220705164426.png" alt="" /></p>

<p>抓过来的数据首先肯定是放在Reducer端的内存缓存区中的（Spark曾经有版本要求只放在内存缓存中，数据结构类似于HashMap（AppendOnlyMap）显然特别消耗内存和极易出现OOM，同时也从Reducer端极大的限制了Spark集群的规模），现在的实现都是内存+磁盘的方式(数据结构使用ExternalAppendOnlyMap)，当然也可以通过Spark.shuffle.spill=false来设置只能使用内存。使用ExternalAppendOnlyMap的方式时候如果内存使用达到一定临界值，会首先尝试在内存中扩大ExternalAppendOnlyMap（内部有实现算法），如果不能扩容的话才会spill到磁盘。
<img src="images/20220705170336.png" alt="" /></p>

<p><strong>hive sql 原理和spark差不多</strong></p>

<h1 id="文章参考">文章参考</h1>

<ol>
  <li><a href="http://www.pingtaimeng.com/article/detail/id/2119447">深入理解web开发中海量小文件带来的的危害及解决方案</a></li>
  <li><a href="http://t.zoukankan.com/thinksasa-p-3013445.html">深入理解磁盘文件系统之inode</a></li>
  <li><a href="https://zhuanlan.zhihu.com/p/67061627">Spark Shuffle 详解</a></li>
</ol>]]></content><author><name></name></author><category term="bigdata" /><summary type="html"><![CDATA[引言]]></summary></entry><entry><title type="html">列存储与向量化执行</title><link href="https://myyyy.github.io/blog/2023/%E5%88%97%E5%AD%98%E5%82%A8%E4%B8%8E%E5%90%91%E9%87%8F%E5%8C%96%E6%89%A7%E8%A1%8C/" rel="alternate" type="text/html" title="列存储与向量化执行" /><published>2023-03-01T00:00:00+00:00</published><updated>2023-03-01T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2023/%E5%88%97%E5%AD%98%E5%82%A8%E4%B8%8E%E5%90%91%E9%87%8F%E5%8C%96%E6%89%A7%E8%A1%8C</id><content type="html" xml:base="https://myyyy.github.io/blog/2023/%E5%88%97%E5%AD%98%E5%82%A8%E4%B8%8E%E5%90%91%E9%87%8F%E5%8C%96%E6%89%A7%E8%A1%8C/"><![CDATA[<h1 id="什么是列存储">什么是列存储</h1>

<blockquote>
  <p>我们知道，在SQL Server里，Page是数据存储的基本单位，而数据行是实际数据的存储单位，它们从Page &gt; Header之后就开始依次存储在Page上。这种按行在Page上存储记录的方式就是行存储。当数据是按单列而不是多行进行连续存储时，就是所谓的列存储。</p>
</blockquote>

<p>列式存储(column-based)是相对于传统关系型数据库的行式存储(Row-basedstorage)来说的。简单来说两者的区别就是如何组织表：</p>

<p><img src="images/2022-01-17-15-26-33.png" alt="" /></p>

<p><strong>行存储</strong>: 基于行的存储按行顺序存放数据。它利于数据一行一行的写入，写入一条数据记录时，只需要将数据追加到已有数据记录后面即可。行模式存储适合 OLTP(Online Transaction Processing)系统。因为数据基于行存储，所以数据的写入会更快。对按记录查询数据也更简单。</p>

<p><strong>列存储</strong>:基于列的存储可按列顺序存放数据。可以方便的取出某一列的全部数据,且只需一次磁盘操作即可。但数据更新复杂度提高,当一条新数据到来，需要将每一列存储到对应的位置。这样就需要多次写磁盘操作。如下图</p>

<p><img src="images/2022-01-17-15-31-06.png" alt="" /></p>
<h2 id="对比">对比</h2>
<p>|  Row-Store   | Column-Store  |
|  —-  | —-  |
| 因为按一行一行写和读取数据，因此读取数据时往往需要读取那些不必要的列  | 可以只读取必要的列 |
| 易于按记录读写数据  | 对一个一个记录的数据写入和读取都较慢 |
| 适合 OLTP 系统  | 适合 OLAP 系统 |
| 不利于大数据集的聚合统计操作  | 利于大数据集的数据聚合操作 |
| 不利于压缩数据  | 利于压缩数据 |</p>

<h1 id="什么是向量化执行">什么是向量化执行</h1>
<p><strong>简单理解为就是消除程序循环的优化</strong></p>
<blockquote>
  <p>向量化计算是一种特殊的并行计算的方式，相比于一般程序在同一时间只执行一个操作的方式，它可以在同一时间执行多次操作，通常是对不同的数据执行同样的一个或一批指令，或者说把指令应用于一个数组/向量。</p>
</blockquote>

<h2 id="基石">基石</h2>
<p><img src="images/2022-01-17-15-58-22.png" alt="" />
离CPU越远访问越慢</p>

<h2 id="向量化执行速度快的原理">向量化执行速度快的原理:</h2>

<ol>
  <li>
    <p>SIMD 处理 (Single Instruction Multiple Data) 即单条指令操作多条数据——原理即在CPU 寄存器层面实现数据的并行操作。SIMD 指令允许在同一时钟周期内，对不同的列数据执行相同的指令, 实际上执行吞吐量（throughput of execution）可以提高 4 倍或更多。</p>
  </li>
  <li>
    <p>列存储
每列的数据存储在一起，可以认为这些数据是以数组的方式存储的，基于这样的特征，当该列数据需要进行某一同样操作，可以使用SIMD进一步提升计算效率，即便运算的机器上不支持SIMD, 也可以通过一个循环来高效完成对这个数据块各个值的计算。</p>
  </li>
</ol>

<h2 id="向量化执行引擎的优势">向量化执行引擎的优势</h2>
<ol>
  <li>向量化执行引擎可以减少节点间的调度，提高CPU的利用率</li>
  <li>因为列存数据，同一列的数据放在一起，导致向量化执行引擎在执行的时候拥有了更多的机会能够利用的当前硬件与编译的新优化特征</li>
  <li>因为列存数据存储将同类型的类似数据放在一起使得压缩比能够达到更高，这样可以拉近一些磁盘IO能力与计算能力的差距</li>
</ol>]]></content><author><name></name></author><category term="bigdata" /><summary type="html"><![CDATA[什么是列存储]]></summary></entry><entry><title type="html">大数据时代，如何进行数仓建模</title><link href="https://myyyy.github.io/blog/2023/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E4%BB%93%E5%BB%BA%E6%A8%A1/" rel="alternate" type="text/html" title="大数据时代，如何进行数仓建模" /><published>2023-02-01T00:00:00+00:00</published><updated>2023-02-01T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2023/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E4%BB%93%E5%BB%BA%E6%A8%A1</id><content type="html" xml:base="https://myyyy.github.io/blog/2023/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%97%B6%E4%BB%A3-%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E6%95%B0%E4%BB%93%E5%BB%BA%E6%A8%A1/"><![CDATA[<h1 id="数仓整体构架">数仓整体构架</h1>
<p><img src="images/e2b98638e23034c4f0442965707aa81141a0934a1a3a22c4c8efd123d8816ebc.png" alt="picture 5" /> 
<img src="images/660889a0a7792dd522c5b687f6fe172a3ab8e023cd26508bdeb170ab02cee783.png" alt="picture 6" /></p>

<ol>
  <li>贴源数据层(ODS)，源业务系统数据的快照，保存细节数据，按天保存。
将业务系统数据库、日志文件等数据，离线或者实时采集到数据仓库中，支持历史数据回溯。表的结构、数据类型和数据源必须保持一致，可过滤敏感字段，对不同业务类型表使用不同的分区策略；</li>
  <li>基础数据层(DWD)，按业务概念组织细节数据，并进行名称、代码等标准化处理。
数据来源于ODS层，面向主题建设，对业务系统数据进行抽象和集成。DW层保存最细粒度的实体数据和维度数据，完成业务元数据标准化和数据清洗工作。</li>
  <li>通用数据层(DWM)，按照星型模型或雪花模型设计方式建设的最细业务粒度汇总层。在本层需要进行指标与维度的标准化，保证指标数据的唯一性。
根据需求状况对DWD数据进行抽象集成，这一层数据不是必须要有的，根据业务需求决定。DWM层数据仍然不会有信息的丢失，主要是信息的快照、拼接等工作。比如业务的用户表（可能来自拉链表）、在比如用户在业务流程不同步骤信息的拼接（如用户下单、付款）</li>
  <li>聚合数据层(DM)，数据来源于DW层，统一通用指标的业务口径，统一指标的多维度开发；标签宽表也构建于该层；DM层数据是根据业务的需求来导向的。</li>
  <li>维度层(DIM)，维度是对具体分析对象的分析角度，维度要具备丰富的属性，历史信息的可追溯性，对通用的维表要保持一致性。</li>
  <li>临时层(TMP)，用来降低加工过程计算难度，提高运行效率的临时表层。
应用数据层(ADS)，这一层跟业务系统强相关，可由业务方直接开发，也可由数仓团队开发，内容跟系统需求导向的。此层不作为数仓核心分层架构。</li>
</ol>

<h2 id="表命名规范">表命名规范</h2>
<p>常规表是我们需要固化的表，是正式使用的表，是目前一段时间内需要去维护去 完善的表。
规范：分层前缀[dwd|dws|ads]_部门_业务域_主题域_XXX_更新周期|数据范围</p>

<h2 id="周期数据范围数据表后缀">周期/数据范围（数据表后缀）：</h2>

<p>日快照：d
增量：i
全量：f
周：w
拉链表：chain</p>

<h1 id="数仓sqldemo">数仓SQLDemo</h1>
<h2 id="原表数据-ods_device_active">原表数据 ods_device_active</h2>

<table>
  <thead>
    <tr>
      <th>序号</th>
      <th style="text-align: center">字段</th>
      <th style="text-align: center">字段类型</th>
      <th style="text-align: center">字段描述</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td style="text-align: center">imei</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">imei</td>
    </tr>
    <tr>
      <td>2</td>
      <td style="text-align: center">android_id</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">android_id</td>
    </tr>
    <tr>
      <td>3</td>
      <td style="text-align: center">model</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">model</td>
    </tr>
    <tr>
      <td>4</td>
      <td style="text-align: center">platform</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">平台号</td>
    </tr>
    <tr>
      <td>5</td>
      <td style="text-align: center">app_ver</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">App版本</td>
    </tr>
    <tr>
      <td>6</td>
      <td style="text-align: center">net</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">网络</td>
    </tr>
    <tr>
      <td>7</td>
      <td style="text-align: center">region</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">region</td>
    </tr>
    <tr>
      <td>8</td>
      <td style="text-align: center">sdk_ver</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">sdk_ver</td>
    </tr>
    <tr>
      <td>9</td>
      <td style="text-align: center">client_time</td>
      <td style="text-align: center">BIGINT</td>
      <td style="text-align: center">客户端时间</td>
    </tr>
    <tr>
      <td>10</td>
      <td style="text-align: center">ip</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">ip</td>
    </tr>
    <tr>
      <td>11</td>
      <td style="text-align: center">properties</td>
      <td style="text-align: center">MAP&lt;STRING,STRING&gt;</td>
      <td style="text-align: center">额外的字段</td>
    </tr>
    <tr>
      <td>12</td>
      <td style="text-align: center">etl_tm</td>
      <td style="text-align: center">STRING</td>
      <td style="text-align: center">etl_tm</td>
    </tr>
  </tbody>
</table>

<h2 id="激活数仓建模构架">激活数仓建模构架</h2>
<h3 id="数仓分层设计">数仓分层设计</h3>
<p><img src="images/d907f384aff9afc635012717dc019525ca60ffda996f2f9970bcda55689466dd.png" alt="picture 1" /><br />
| 层级        | 表名字   |  备注  |
| ——–   | :—–:  | :—-:  |
| ods     | ods.ods_device_active |   |
| dwd     | isubject.dwd_dvc_active_di |   |
| dwd     | isubject.dwd_dvc_active_df |   |
| dwd     | icube.ads_dvc_active_d  |   |
| dwd     | icube.ads_dvc_active_retain_d |   |</p>

<h3 id="dwd_dvc_active_di-开发">dwd_dvc_active_di 开发</h3>

<pre><code class="language-SQL">insert overwrite table xxx.dwd_dvc_active_di partition( date = ${date - 1})
select  
imei,
android_id,
model,
platform,
app_ver,
net,
region,
sdk_ver,
ip2address(ip)[0] as country,
ip2address(ip)[1] as province,
ip2address(ip)[2] as city,
properties['device'] as product,
etl_tm,
from_unixtime(cast(client_time/1000 as int),'yyyyMMdd')as tm,
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') AS etl_tm
from ods.ods_device_active  where date=${date - 1}
</code></pre>
<h3 id="dwd_dvc_active_df开发">dwd_dvc_active_df开发</h3>

<pre><code class="language-SQL">with tmp as (
select  
coalesce(t1.android_id,t2.android_id),
coalesce(t1.region,t2.region),
coalesce(t1.model,t2.model),
coalesce(t1.product,t2.product),
coalesce(t1.app_ver,t2.app_ver),
coalesce(t1.net,t2.net),
coalesce(t1.country,t2.country),
coalesce(t1.province,t2.province),
coalesce(t1.city,t2.city),
least(t2.first_active_time,t1.first_active_time), --greatest 返回最小
greatest(t2.last_active_time,t1.last_active_time)--greatest 返回最大
from 
(
    --需要保证android_id是唯一主键
    select 
    android_id,region,model,product,app_ver,os_ver,
    net,country,province,city,
    min(tm) as first_active_time,max(tm) as last_active_time
    from isubject.dwd_dvc_active_di 
    where date= ${date - 1} 
    and android_id is not null
    group by android_id,region,model,product,app_ver,os_ver,
    net,country,province,city

)t1
FULL JOIN (
    select  
    android_id,region,model,product,app_ver,os_ver,
    net,country,province,city,
    first_active_time,last_active_time
    from isubject.dwd_dvc_active_di where date= ${date - 2}
)t2
on t1.android_id=t2.android_id
)
INSERT OVERWRITE TABLE isubject.dwd_dvc_active_df PARTITION(date=${date-1})
select *,from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') AS etl_tm from tmp

</code></pre>

<h3 id="ads_dvc_active_d开发">ads_dvc_active_d开发</h3>

<pre><code class="language-SQL">
with tmp0 as (
    SELECT
    app_ver,model,os_ver,product,net,country,province,city,
    if(first_active_time==${date - 1},1,0) as d,
    if(first_active_time&gt;=${date - 6} and first_active_time&lt;=${date - 1},1,0) as d7,
    if(first_active_time&gt;=${date - 29} and first_active_time&lt;=${date - 1},1,0) as d30,
    if(last_active_time==${date - 1},1,0) as a,
    if(last_active_time&gt;=${date - 6} and last_active_time&lt;=${date - 1},1,0) as a7,
    if(last_active_time&gt;=${date - 29} and last_active_time&lt;=${date - 1},1,0) as a30,
    1 as tu
    from isubject.dwd_dvc_active_df
    where date=${date - 1}
),
tmp2 as (
    select 
    0 as idc,--集群
    GROUPING__ID as group_flag,
    app_ver,model,os_ver,product,net,country,province,city,
    sum(d),
    sum(d7),
    sum(d30),
    sum(a),
    sum(a7),
    sum(a30),
    sum(tu)
    from tmp0
    group by app_ver,model,os_ver,product,net,country,province,city
    grouping sets (
        ( app_ver,model,os_ver,product,net,country,province,city) 
    )
)
INSERT OVERWRITE TABLE icube.ads_dvc_active_d PARTITION(date=${date-1},source='APP-A') --source 二级分区 依据需要建表时设置
select*,from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') AS etl_tm from tmp2

</code></pre>

<h3 id="ads_dvc_active_retain_d">ads_dvc_active_retain_d</h3>

<pre><code class="language-SQL">with tmp as (
    select 
    from_unixtime(unix_timestamp(startDate,'yyyy-MM-dd'),'yyyyMMdd') as base_date,
    app_ver,model,os_ver,product,net,country,province,city,
    count(distinct t0.android_id) as dau,
    count(distinct if(datediff(endDate, startDate)=1,t0.android_id,null)) as retention_1d,
    count(distinct if(datediff(endDate, startDate)=2,t0.android_id,null)) as retention_2d,
    count(distinct if(datediff(endDate, startDate)=3,t0.android_id,null)) as retention_3d,
    count(distinct if(datediff(endDate, startDate)=4,t0.android_id,null)) as retention_4d,
    count(distinct if(datediff(endDate, startDate)=5,t0.android_id,null)) as retention_5d,
    count(distinct if(datediff(endDate, startDate)=6,t0.android_id,null)) as retention_6d,
    count(distinct if(datediff(endDate, startDate)=7,t0.android_id,null)) as retention_7d,
    count(distinct if(datediff(endDate, startDate)=14,t0.android_id,null)) as retention_14d,
    count(distinct if(datediff(endDate, startDate)=30,t0.android_id,null)) as retention_30d
    from 
    (
        select 
        app_ver,model,os_ver,product,net,country,province,city,
        from_unixtime(unix_timestamp(cast(date AS string),'yyyyMMdd'),'yyyy-MM-dd') AS startDate
        from isubject.dwd_dvc_active_df 
        where date between ${date-30} and ${date-1}
        and last_active_time=date
    )t0
    left join
    (
        select
        from_unixtime(unix_timestamp(cast(date AS string),'yyyyMMdd'),'yyyy-MM-dd') AS endDate,
        android_id
        from isubject.dwd_dvc_active_df 
        where date between ${date-30} and ${date-1}
        and last_active_time=date
        group by date,android_id
    )t1
    on t0.android_id=t1.android_id
    group by startDate,app_ver,model,os_ver,product,net,country,province,city,

)
INSERT OVERWRITE TABLE icube.ads_dvc_active_retain_d PARTITION(date=${date - 1},source='APP-A')
select
app_ver,model,os_ver,product,net,country,province,city,
sum(dau),
sum(retention_1d),
sum(retention_2d),
sum(retention_3d),
sum(retention_4d),
sum(retention_5d),
sum(retention_6d),
sum(retention_7d),
sum(retention_14d),
sum(retention_30d),
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') as etl_tm
from tmp
group by app_ver,model,os_ver,product,net,country,province,city,

</code></pre>

<h1 id="拉链表开发">拉链表开发</h1>
<blockquote>
  <p>相关文档 <a href="../拉链表.pdf">拉链表介绍</a>
基于ods.ods_device_active 贴源数据层 可以设计出基于激活拉链表，节省存储空间。
<strong>表结构如下(字段需根据具体需求确认)</strong></p>
</blockquote>

<p>表名:isubject.dwd_dvc_active_chain
|序号|字段|字段类型|字段描述|
| ——– | :—–:| :—-:|:—-:|
|1|imei|STRING|imei|
|9|first_day|BIGINT|创建时间|
|9|last_day|BIGINT|修改时间|
|12|etl_tm|STRING|etl_tm|
|9|start_day|BIGINT|start_day|
|分区|end_day|i64|闭链时间|</p>

<p><strong>SQL如下</strong></p>
<pre><code class="language-SQL">--增量拉链
set parquet.compression=SNAPPY;
set hive.exec.parallel=true;
set hive.map.aggr=true;
set hive.merge.mapfiles = true;
set hive.merge.mapredfiles = true;
set hive.merge.size.per.task = 256000000;
set hive.merge.smallfiles.avgsize = 200000000;
set hive.input.format=org.apache.hadoop.hive.ql.io.CombineHiveInputFormat;

from 
(
    select imei,first_day,last_day,start_day
    from isubject.dwd_dvc_active_chain 
    where start_day &lt;= ${date-2} and end_day &gt; ${date-2}
)t1
full join(
    select imei from isubject.dwd_dvc_active_di	
    where date=${date-1}
    group by imei
)t2 
on t1.did = t2.did

insert overwrite table isubject.dwd_dvc_active_chain partition(end_day=20991231)
select
coalesce(t2.imei,t1.imei) as imei,
coalesce(t1.first_day,${date-1}) as first_day,
if(isnotnull(t2.imei),${date-1},t1.last_day) as last_day,
if(isnotnull(t2.imei),${date-1},t1.start_day) as start_day,
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') as etl_tm
distribute by rand()

insert overwrite table isubject.dwd_dvc_active_chain partition(end_day=${date-1})
select 
t1.imei,
t1.first_day,
t1.last_day,
t1.start_day as start_day,
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') as etl_tm
where  t1.imei is not null and  t2.imei is not null
distribute by rand()
;
</code></pre>

<p><strong>如果是配置表有可能需要保存删除状态，表需要增加字段del_flg，拉链表SQL如下</strong></p>

<p>表名:isubject.dwd_dvc_active_chain
|序号|字段|字段类型|字段描述|
| ——– | :—–:| :—-:|:—-:|
|1|imei|STRING|imei|
|2|del_flg|STRING|del_flg|
|3|app_ver|STRING|App_版本|
|4|model|STRING|model|
|5|first_day|BIGINT|创建时间|
|6|last_day|BIGINT|修改时间|
|7|etl_tm|STRING|etl_tm|
|8|start_day|BIGINT|start_day|</p>

<pre><code class="language-SQL">--全量拉链
from 
(
    select imei,first_day,last_day,start_day
    from isubject.dwd_dvc_active_chain 
    where start_day &lt;= ${date-2} and end_day &gt; ${date-2}
)t1
full join(
    select imei,0 as del_flg,app_ver,model from isubject.dwd_dvc_active_di	
    where date=${date-1}
    group by imei
    --这个地方需要保证imei是唯一主键 才能做拉链 
)t2 
on t1.did = t2.did

insert overwrite table isubject.dwd_dvc_active_chain partition(end_day=20991231) --最新的数据 包含删除的数据
select
coalesce(t2.imei,t1.imei) as imei,
coalesce(t2.del_flg,1),
coalesce(t2.app_ver,t1.app_ver) as app_ver,
coalesce(t2.model,t1.model) as model,
coalesce(t1.first_day,${date-1}) as first_day,
if(isnotnull(t2.imei),${date-1},t1.last_day) as last_day,
IF(
    (t1.del_flg =1 and t2.imei IS NULL) 
    OR (t1.imei=t2.imei and 
    coalesce(t1.app_ver,0)=coalesce(t2.app_ver,0) and
     coalesce(t1.model,0)=coalesce(t2.model,0)
    ),
    t1.start_day,${date-1}
    ) AS start_day,
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') as etl_tm
distribute by rand()

insert overwrite table isubject.dwd_dvc_active_chain partition(end_day=${date-1}) --历史${date-1}天的数据,不包含${date-1}天前删除的数据
select 
t1.imei,
t1.del_flg,
t1.app_ver,
t1.model,
t1.first_day,
t1.last_day,
t1.start_day as start_day,
from_unixtime(unix_timestamp(),'yyyy-MM-dd HH:mm:ss') as etl_tm
where  t1.imei is not null 
AND
( (t2.imei is null and t1.del_flg=0 ) or 
  (t2.imei is not null and (
    coalesce(t1.app_ver,0)&lt;&gt;coalesce(t2.app_ver,0) or
    coalesce(t1.model,0)&lt;&gt;coalesce(t2.model,0)
    ))
) 
distribute by rand()
;
</code></pre>]]></content><author><name></name></author><category term="bigdata" /><summary type="html"><![CDATA[大数据时代，如何进行数仓建模]]></summary></entry><entry><title type="html">数仓规范指南</title><link href="https://myyyy.github.io/blog/2022/%E6%95%B0%E4%BB%93%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/" rel="alternate" type="text/html" title="数仓规范指南" /><published>2022-10-22T00:00:00+00:00</published><updated>2022-10-22T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2022/%E6%95%B0%E4%BB%93%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97</id><content type="html" xml:base="https://myyyy.github.io/blog/2022/%E6%95%B0%E4%BB%93%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/"><![CDATA[<h3 id="引用">引用</h3>
<ol>
  <li><a href="https://www.cnblogs.com/itlz/p/15539258.html">最强最全面的数仓建设规范指南 </a></li>
  <li><a href="https://www.cnblogs.com/itlz/p/15539258.html">数仓规范指南</a></li>
  <li><a href="https://mp.weixin.qq.com/s/9YR2FBfo1ufyF2G-M-JNhQ">美团数据平台及数仓建设实践，超十万字总结</a></li>
</ol>]]></content><author><name></name></author><category term="bigdata" /><summary type="html"><![CDATA[引用 最强最全面的数仓建设规范指南 数仓规范指南 美团数据平台及数仓建设实践，超十万字总结]]></summary></entry><entry><title type="html">docker入门</title><link href="https://myyyy.github.io/blog/2017/docker%E5%85%A5%E9%97%A8/" rel="alternate" type="text/html" title="docker入门" /><published>2017-03-17T00:00:00+00:00</published><updated>2017-03-17T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2017/docker%E5%85%A5%E9%97%A8</id><content type="html" xml:base="https://myyyy.github.io/blog/2017/docker%E5%85%A5%E9%97%A8/"><![CDATA[<p>#docker的环境配置</p>

<blockquote>
  <p>sudo apt-get update
sudo apt-get install docker.io</p>
</blockquote>

<p>#docker加速器配置</p>

<p>使用配置文件 /etc/docker/daemon.json（没有时新建该文件）
{
   “registry-mirrors”: [“<your accelerate="" address="">"]
}
注:基于阿里云的镜像加速</your></p>

<h1 id="下拉项目运行环境">下拉项目运行环境</h1>

<p>sudo docker pull registry.cn-hangzhou.aliyuncs.com/zhangxj/smartbow-web:0.2 
注:可跟你不同项目的需要配置不同的运行环境</p>

<p>#运行docker image</p>

<p>docker run –name web -ti registry.cn-hangzhou.aliyuncs.com/zhangxj/smartbow-web:0.2 bash</p>

<p>#编写脚本文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>name:up.sh
#!/bin/bash
docker stop web
docker rm -v web

docker run --name web -ti -p 8887:8887 -p 8888:8888 -v /home/suyf/swork/git:/app registry.cn-hangzhou.aliyuncs.com/zhangxj/smartbow-web:0.2 bash
</code></pre></div></div>

<p>#命令</p>
<ol>
  <li>退出docker容器(非中断模式)
    <ul>
      <li>ctrl + P ctrl + q</li>
    </ul>
  </li>
  <li>进入docker image
    <ul>
      <li>docker exec -it container_id bash #不会终止</li>
      <li>docker attach <container> #需要注意的是，如果从这个stdin中exit，会导致容器的停止</container></li>
    </ul>
  </li>
  <li>检查容器运行
    <ul>
      <li>docker ps</li>
      <li>docker ps -a</li>
    </ul>
  </li>
  <li>查看容器信息
    <ul>
      <li>docker inspect <container></container></li>
    </ul>
  </li>
  <li>杀死or删除
    <ul>
      <li>docker stop <container></container></li>
      <li>docker kill <container></container></li>
      <li>docker rm <container></container></li>
      <li>docker rm $(docker ps -aq) #移除所有</li>
    </ul>
  </li>
</ol>

<p>#参考链接</p>
<blockquote>
  <p><a href="http://www.linuxidc.com/Linux/2015-05/117510.htm">docker命令简单介绍</a></p>
</blockquote>]]></content><author><name></name></author><category term="other" /><summary type="html"><![CDATA[docker的初步应用]]></summary></entry><entry><title type="html">Tornado设置默认403(error)页面</title><link href="https://myyyy.github.io/blog/2017/tornado%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4403(error)%E9%A1%B5%E9%9D%A2/" rel="alternate" type="text/html" title="Tornado设置默认403(error)页面" /><published>2017-03-17T00:00:00+00:00</published><updated>2017-03-17T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2017/tornado%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4403(error)%E9%A1%B5%E9%9D%A2</id><content type="html" xml:base="https://myyyy.github.io/blog/2017/tornado%E8%AE%BE%E7%BD%AE%E9%BB%98%E8%AE%A4403(error)%E9%A1%B5%E9%9D%A2/"><![CDATA[<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">os</span>
<span class="kn">import</span> <span class="n">tornado</span>
<span class="kn">import</span> <span class="n">tornado.options</span>
<span class="kn">import</span> <span class="n">tornado.httpserver</span>
<span class="kn">from</span> <span class="n">tornado.web</span> <span class="kn">import</span> <span class="n">RequestHandler</span>
<span class="kn">from</span> <span class="n">tornado.options</span> <span class="kn">import</span> <span class="n">define</span><span class="p">,</span> <span class="n">options</span>

<span class="nf">define</span><span class="p">(</span><span class="sh">"</span><span class="s">port</span><span class="sh">"</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">1994</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="sh">"</span><span class="s">run on the given port</span><span class="sh">"</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">BaseHandler</span><span class="p">(</span><span class="n">tornado</span><span class="p">.</span><span class="n">web</span><span class="p">.</span><span class="n">RequestHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">write_error</span><span class="p">(</span><span class="n">self</span><span class="p">,</span><span class="n">status_code</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">status_code</span> <span class="o">==</span> <span class="mi">403</span> <span class="ow">or</span> <span class="mi">405</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">dict</span><span class="p">(</span><span class="n">status</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
                <span class="n">data</span> <span class="o">=</span> <span class="sh">'</span><span class="s">对不起，你没有权限访问该页面；如需帮助，请联系管理员 </span><span class="sh">'</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">self</span><span class="p">.</span><span class="nf">get_error_html</span><span class="p">(</span><span class="n">status_code</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_error_html</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">status_code</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">template_name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">{0}.html</span><span class="sh">"</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="n">status_code</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nf">exists</span><span class="p">(</span><span class="nf">template_path</span><span class="p">(</span><span class="n">template_name</span><span class="p">)):</span>
            <span class="n">template_name</span> <span class="o">=</span> <span class="sh">"</span><span class="s">error.html</span><span class="sh">"</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nf">exists</span><span class="p">(</span><span class="nf">template_path</span><span class="p">(</span><span class="n">template_name</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">self</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="nf">str</span><span class="p">(</span><span class="n">status_code</span><span class="p">))</span>

        <span class="n">kwargs</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span>
            <span class="nf">dict</span><span class="p">(</span><span class="n">status_code</span><span class="o">=</span><span class="n">status_code</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">responses</span><span class="p">[</span><span class="n">status_code</span><span class="p">]))</span>

        <span class="n">self</span><span class="p">.</span><span class="nf">render</span><span class="p">(</span><span class="n">template_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">IndexHandler</span><span class="p">(</span><span class="n">BaseHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">write</span><span class="p">(</span><span class="sh">'</span><span class="s">hello</span><span class="sh">'</span><span class="p">)</span>

<span class="n">handlers</span> <span class="o">=</span> <span class="p">[</span> 
    <span class="p">(</span><span class="sa">r</span><span class="sh">'</span><span class="s">/index</span><span class="sh">'</span><span class="p">,</span> <span class="n">IndexHandler</span><span class="p">),</span>
    <span class="p">]</span>   

<span class="n">settings</span> <span class="o">=</span> <span class="p">{</span> 
        <span class="sh">'</span><span class="s">template_path</span><span class="sh">'</span><span class="p">:</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">),</span> <span class="sh">"</span><span class="s">templates</span><span class="sh">"</span><span class="p">),</span>
        <span class="sh">'</span><span class="s">static_path</span><span class="sh">'</span><span class="p">:</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="nf">dirname</span><span class="p">(</span><span class="n">__file__</span><span class="p">),</span> <span class="sh">'</span><span class="s">static</span><span class="sh">'</span><span class="p">),</span>
        <span class="p">}</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">__main__</span><span class="sh">'</span><span class="p">:</span>
        <span class="n">tornado</span><span class="p">.</span><span class="n">options</span><span class="p">.</span><span class="nf">parse_command_line</span><span class="p">()</span>
        <span class="n">app</span> <span class="o">=</span> <span class="n">tornado</span><span class="p">.</span><span class="n">web</span><span class="p">.</span><span class="nc">Application</span><span class="p">(</span><span class="n">handlers</span><span class="o">=</span><span class="n">handlers</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">)</span>
        <span class="n">http_server</span> <span class="o">=</span> <span class="n">tornado</span><span class="p">.</span><span class="n">httpserver</span><span class="p">.</span><span class="nc">HTTPServer</span><span class="p">(</span><span class="n">app</span><span class="p">)</span>
        <span class="n">http_server</span><span class="p">.</span><span class="nf">listen</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">port</span><span class="p">)</span>
        <span class="nf">print</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">port</span><span class="p">)</span>
        <span class="n">tornado</span><span class="p">.</span><span class="n">ioloop</span><span class="p">.</span><span class="n">IOLoop</span><span class="p">.</span><span class="nf">instance</span><span class="p">().</span><span class="nf">start</span><span class="p">()</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="python" /><summary type="html"><![CDATA[``` python import os import tornado import tornado.options import tornado.httpserver from tornado.web import RequestHandler from tornado.options import define, options]]></summary></entry><entry><title type="html">Tornado源码解析之ioloop</title><link href="https://myyyy.github.io/blog/2017/Tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BIoLoop/" rel="alternate" type="text/html" title="Tornado源码解析之ioloop" /><published>2017-03-15T00:00:00+00:00</published><updated>2017-03-15T00:00:00+00:00</updated><id>https://myyyy.github.io/blog/2017/Tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BIoLoop</id><content type="html" xml:base="https://myyyy.github.io/blog/2017/Tornado%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B9%8BIoLoop/"><![CDATA[<p>##预备知识</p>

<ol>
  <li>hasattr()&amp;getattr()
    <ul>
      <li>hasattr(object, name):判断一个对象是否有’name’属性或者’name’方法
 *getattr(object, name[,default]):获取对象object的属性或者方法，如果存在打印出来，如果不存在，打印出默认值，默认值可选。(如果获得的是方法,则返回的是方法的内存地址,有需要运行则需要加’()’)</li>
    </ul>
  </li>
  <li>classmethod &amp; staticmethod
    <ul>
      <li>待完善</li>
    </ul>
  </li>
  <li>future模块&amp;yeild
    <ul>
      <li>future:Python提供了__future__模块，把下一个新版本的特性导入到当前版本</li>
      <li>yeild: yield的英文单词意思是生产,若某个函数包含yield，这意味着这个函数已经是一个Generator<a href="http://www.pythontab.com/html/2015/pythonhexinbiancheng_0415/946.html">深入理解yield</a></li>
    </ul>
  </li>
  <li>python concurrent 模块
    <ul>
      <li>因python GIL全局锁的机制,产生了<a href="http://www.bubuko.com/infodetail-167068.html">concurrent</a>一个实现并发的模块</li>
    </ul>
  </li>
  <li>NotImplementedError()异常处理机制
    <ul>
      <li>NotImplemented 是一个非异常对象，NotImplementedError 是一个异常对象.<a href="http://www.tuicool.com/articles/JRb6Zr">参考链接</a>
 *<a href="https://segmentfault.com/q/1010000005012781">tornado 预定义接口返回异常的好处</a> 
 *<a href="https://blog.zorro.im/tornado-configurable/">tornado Configureable类</a></li>
    </ul>
  </li>
  <li>
    <p>Synchronous(同步)&amp;Asynchronous(异步)
 *理解概念<a href="http://www.cnblogs.com/anny0404/p/5691379.html">链接</a></p>
  </li>
  <li>
    <p>fileno()文件描述符
 *件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>

    <ul>
      <li>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统</li>
    </ul>
  </li>
  <li>double ckeck问题
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> if not hasattr(IOLoop, "_instance"):
 with IOLoop._instance_lock:
     if not hasattr(IOLoop, "_instance"):
         # New instance after double check
         IOLoop._instance = IOLoop()
</code></pre></div>    </div>

    <ul>
      <li><a href="http://www.jb51.net/article/80363.htm">torndao中单例模式的应用</a></li>
    </ul>
  </li>
  <li>select、poll、epoll
    <ul>
      <li><a href="Linux IO模式及 select、poll、epoll详解">Linux IO模式及 select、poll、epoll详解</a></li>
    </ul>
  </li>
</ol>]]></content><author><name></name></author><category term="python" /><summary type="html"><![CDATA[##预备知识]]></summary></entry></feed>